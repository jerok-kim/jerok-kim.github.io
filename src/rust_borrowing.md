#패스트캠퍼스, #국비지원교육, #메가바이트스쿨, #MegabyteSchool, #개발자취업부트캠프, #내일배움카드

*last edited 2023.01.26*

# 빌림과 참조에 대해 쉬운 설명으로 알아보자

> ▶ 만들면서 배우는 러스트 프로그래밍 -쿠지라 히코우즈쿠에- ◀ 을 참조하여 정리하였다.

소유권은 함수를 호출해도 이동한다. 하지만 함수를 호출할 때마다 소유권이 이동하면 프로그래밍이 어려워진다. 그래서 일시적으로 소유권을 빌리는 '빌림'에 대해 알아보자. 빌림 외에도 함수와 소유권의 관계, 참조에
대해서도 알아본다.

## '빌림'이란

'빌림'은 빌려쓴다는 뜻이다. 실생활에서도 자기 것이 아닌 물건을 원 주인의 양해를 받고 가져와 쓰는 것을 빌린다고 한다.

러스트에서 말하는 빌림(borrow/borrowing)도 의미는 같지만 여기서는 물건이 아니라 값의 소유권이다. 그리고 빌리는 것이므로 소유권을 완전히 받는 것이 아니라 일시적으로 가져오고 사용이 끝나면 반납한다.

## 함수 호출로 이동하는 소유권

소유권은 값 대입 외 함수 호출로도 이동한다. 함수를 호출할 때 인수로 값을 지정하면 그 값의 소유권은 호출한 함수의 인수로 이동한다.

함수 호출에 따른 소유권 이동에 대해 자세히 살펴보자.

```rust, noplayground
fn main() {
    let g1 = String::from("실수할 줄 아는 사람이 아름답다.");
    show_message(g1);  // 소유권이 이동한다
    println!("{}", g1);  // g1은 사용할 수 없다.
}

fn show_message(message: String) {
    println!("{}", message);
}
```

이 프로그램을 컴파일하면 다음과 같이 에러가 발생한다.

```text
$ rustc owner_func_err.rs
error[E0382]: borrow of moved value: `g1`
 --> owner_func_err.rs:4:20
  |
2 |     let g1 = String::from("실수할 줄 아는 사람이 아름답다");
  |         -- move occurs because `g1` has type `String`, which does not implement the `Copy` trait       
3 |     show_message(g1);  // 소유권이 이동한다
  |                  -- value moved here
4 |     println!("{}", g1);  // g1은 사용할 수 없다
  |                    ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
```

에러 메시지를 확인해보자. 직접적인 에러는 'error[E0382]: borrow of moved value: `g1`(이동된 값 g1을 빌림)'이다.

여기서 주목할 점은 어디에서 `g1`의 값이 이동했는지다. 프로그램의 3번째 줄에서 호출한 함수 `show_message`의 인수 `g1`부분에 'value moved here(여기에서 값이 이동됨)'이라는 힌트가
표시된다.

즉 함수 호출로 소유권 이동이 발생했으므로 4번째 줄의 `println!`에서 `g1`의 값을 사용할 수 없게 된 것이다.

### 소유권 돌려주기

앞의 예제에서는 변수 `g1`의 소유권이 이동했으므로 에러가 발생했다. 이번에는 `g1`을 이용하면 함수를 호출한 곳에 소유권을 돌려주도록 해보자.

```rust, editable
fn main() {
    let mut g1 = String::from("실수할 줄 아는 사람이 아름답다.");
    g1 = show_message(g1);  // (1)
    println!("{}", g1);  // ok (2)
}

// String을 받아 String을 반환하는 함수
fn show_message(message: String) -> String {
    println!("{}", message);
    return message;
}
```

컴파일 후 실행해보면 '실수할 줄 아는 사람이 아름답다.'라는 문장이 2번 출력된다.

소스 코드를 살펴보자. (1)에서는 변수 `g1`의 값을 인수로 지정해 함수를 호출한다. 이를 통해 `g1`값의 소유권은 함수로 넘어간다. 하지만 함수의 반환 값을 통해 소유권을 다시 돌려받는다. 그래서 (2)
에서도 `g1`을 이용할 수 있다.

물컵의 예로 생각하면 `g1`컴에 따라둔 물을 `show_message`함수의 인수 `message`라는 컵으로 옮긴 후 다시 `g1`컵으로 옮긴 상태다.

여기서 변수 `g1`을 선언할 때 `mut`을 붙여 가변 변수로 선언을 했다. 동일한 값인데 `mut`을 선언한 이유는 내부적으로 대입 동작이 발생하기 때문이다. 대입은 초기화와는 다른 동작이므로 값이 변하는 것으로
간주되기 때문이다.

(3)의 함수 `show_message`가 이전 예제와 다른 점은 인수 `message`를 그대로 반환 값으로 한 것이다. 이를 통해 함수를 호출했을 때 값 소유권을 함수의 변수 `message`로 이동한 뒤 실행이
종료되면 다시 함수를 호출한 곳으로 돌려줄 수 있다.

### 참조와 빌림 - 함수 호출을 했을 때 소유권을 이동하지 않는 방법

함수 호출만으로 값의 소유권이 이동하는 것은 불편할 때도 있다. 그래서 러스트에는 소유권을 일시적으로 빌려주는 '빌림(borrow)'이라는 시스템을 마련해두고 있다.

값을 빌리기 위해서는 참조자를 나타내는 `&`을 붙인다. 바꿔 말하면 **함수의 인수를 '참조자'로 만드는 것을 '빌림'이라고 한다**.

앞에서 다룬 예제를 빌림을 이용하는 형태로 변경해보자.

```rust, editable
fn main() {
    let g1 = String::from("실수할 줄 아는 사람이 아름답다.");
    show_message(&g1);  // 참조 값을 전달 (1)
    println!("{}", g1);  // 소유권은 이동하지 않음 (2)
}

fn show_message(message: &String) {  // (3)
    println!("{}", message);
}
```

컴파일 후 실행해보면 앞서와 마찬가지로 `show_message`에서 한 번, `println!`에서 한 번씩 메시지가 출력되어 총 2개의 메시지가 출력된다.

가장 앞 부분에서 설명한 에러가 발생하는 소스 코드와 비교해보면 차이점은 단 2글자뿐이다. (1)에서 함수를 호출할 때 참조자라는 것을 명시하기 위해 `&`를 붙인 것, 그리고 (3)에서 함수의 인자로 참조자를
전달한다는 것을 명시하기 위해 역시 `&`을 붙인 것이 전부다. 이를 통해 (2)에서 변수 `g1`의 값을 이용할 수 있다.

이처럼 참조자를 전달하도록 변경하면 소유권 문제를 해결할 수 있다. **값을 참조해서 사용한다는 것은 값의 소유권을 일시적으로 빌리는 '빌림'이기 때문이다**.

> #### &String은 &str과 다른가
>
> 앞의 프로그램에서는 `String` 타입의 참조 타입인 `&String`을 썼다. 하지만 문자열 참조 타입으로 `&str`을 이용할 수도 있다. 러스트의 많은 함수는 문자열 참조 타입으로 `&str`을
> 이용한다. `&String`과 `&str`은 대부분의 경우 동일하게 사용할 수 있다. 하지만 엄밀히 말하면 `&str`은 슬라이스다. 슬라이스는 배열과 같은 요소의 일부를 참조하기 위한 타입이다. 자세한 내용은
> 문자열에 대해 알아볼때 다뤄보자.

## 참조자를 반환하는 함수

함수에서 참조자를 반환해야 하는 경우도 있다. 예를 들어 함수 안에서 어떠한 데이터를 만들고, 값이 아니라 그 참조자를 반환해야 하는 경우다. 그런데 러스트에서는 값에 수명(Lifetime)이 있다.

다음 소스 코드는 함수 `gen_message`로 메시지를 만든 뒤 그 참조자를 반환하려는 의도로 만들어진 것이다. 하지만 에러가 발생한다. 어떤 부분이 잘못되었는지 살펴보자.

```rust, noplayground
// 메시지를 생성한 뒤 그 참조자를 반환하는 함수
fn gen_message() -> &str {
    let msg = String::from("실수할 줄 아는 사람이 아름답다.");
    return &msg;
}

fn main() {
    let m = gen_message();
    println!("{}", m);
}
```

```text
$ rustc owner_lifetime_err.rs 
error[E0106]: missing lifetime specifier
 --> owner_lifetime_err.rs:2:21
  |
2 | fn gen_message() -> &str {
  |                     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
2 | fn gen_message() -> &'static str {
  |                      +++++++

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
```

에러 메시지를 확인해보자. 'error[E0106]: missing lifetime specifier(수명 지시자가 없음)'이라고 표시된다. 도움말(help)을 보면 'this function's return
type contains a borrowed value, but there is no value for it to be borrowed from(이 함수가 반환하는 값은 빌린 값을 포함하고 있으나 빌림 값이 존재하지
않음)'이라고 표시된다.

즉, 수명을 지정하지 않았기 때문에 에러가 발생한 것이다.

앞에서 '소유자'가 유효한 범위(Scope)를 벗어나면 값은 파기된다'는 소유권 시스템의 기본 원칙을 바탕으로 생각해보자. 함수 `gen_message`는 하나의 범위다. 변수 `msg`는 **이 범위 안에서만
유효하며 범위를 벗어나는 순간 `msg`값은 파기되는 것이다**. 따라서 `msg`의 값에 대한 참조를 반환하더라도 `msg`값은 파기되므로 값이 사라지기 때문에 에러가 발생한다.

그렇다면 이 소스 코드를 어떻게 고쳐야 할까? **참조가 안 된다면 실제값을 이용하면 된다**. 즉 참조가 아닌 `String`객체의 실제값을 반환하도록 수정한다.

```rust, editable
// 메시지 생성 함수
fn gen_message() -> String {
    let msg = String::from("실수할 줄 아는 사람이 아름답다.");
    return msg;  // 소유권이 함수의 반환 값으로 이동 (1)
}

fn main() {
    let m = gen_message();  // 소유권은 m으로 이동 (2)
    println!("{}", m);  // ok
}
```

(1)부분에서 변수 `msg`값의 소유권은 함수의 반환 값으로 이동한다. 즉, (2)부분의 변수 `m`이 `msg`값의 소유권을 가지게 된다. 따라서 `println!` 매크로로 `m`의 값을 출력할 수 있다.

## 가변 참조자를 인수로 사용하기

함수 호출에 참조자를 사용할 때 함수 안에서 인수의 값을 변경해야 하는 경우도 있다. 이때는 참조자가 가변이라는 것을 명시하면 함수 안에서 인수의 값을 변경할 수 있다.

다음은 인수에 지정한 `String` 타입 값을 함수 안에서 변경하는 프로그램이다.

```rust, editable
// 인수의 문자열을 변경하는 함수 (1)
fn add_quote(msg: &mut String) {
    msg.insert(0, '"');
    msg.push('"');
}

fn main() {
    let mut msg = String::from("건강한 신체에 건강한 정신이 깃든다.");
    println!("{}", msg);  // (2)
    add_quote(&mut msg);  // (3)
    println!("{}", msg);  // (4)
}
```

컴파일 후 실행해보면 문자열의 앞뒤에 큰따옴표가 추가된 것을 확인할 수 있다.

함수의 인수로 지정한 값의 참조자를 변경하려면 (1)의 함수 정의에서 인수를 `&mut` 타입 형태로 지정한다. 이렇게 하면 그 타입이 가변 참조자가 된다. 그리고 (3)에서와 같이 함수를 호출할 때 `&mut`을
지정해 함수를 호출한다.

`main`함수를 보면 `String`타입 값을 만들고 가변 변수 `msg`에 대입한다. 그리고 (2)에서 내용을 출력한다. (3)에서는 `add_quote`함수를 호출한다. 호출할 때 인수에 `&mut`을 추가해
가변 참조자라는 것을 명시한다. `add_quote`함수는 `msg`의 앞과 뒤에 큰따옴표를 추가한다. 그리고 (4)에서 큰따옴표가 추가된 문자열을 출력한다.

여기서 주의할 것은 `add_quote`함수를 호출할 때 값 그 자체가 아니라 `mut`에 `&`를 붙여 가변 참조자를 지정한다는 점이다. 참조자이므로 값을 빌리기만 하므로 (4)에서 `msg`를 이용할 수 있다.

### 함수를 호출해서 인수를 변경하는 방법

함수의 인수로 지정한 변수를 변경하는 방법을 다시 한번 확인하자. 문법은 다음과 같다.

```rust, noplayground
// 함수 정의
fn 함수이름(변수명: &mut 타입) {
    // 실제값을 얻음
    let value = *변수명;
    
    // 변수를 갱신
    *변수명 = 새로운 값;
}

// 함수 호출
함수(&mut 변수);
```

함수를 정의할 때 변수에 대한 참조자를 전달할 수 있게 `변수명: &mut 타입`을 지정한다. 그리고 함수를 호출할 때는 `함수(&mut 변수)`와 같이 변수가 가변이며 참조자라는 것을 명시한다.

함수의 실제 내용에는 변수의 참조자로부터 실제값을 얻기 위해 `*변수명`과 같이 기술한다. 이것을 '역참조(dereference)'라고 한다. 값을 변경하는 경우에도 역참조를 지정해 `*변수명 = 새로운 값;`과
같이 기술한다.

### 인수를 변경하는 예

다음은 가변 변수를 선언한 뒤 함수를 이용해 원래의 변수값을 변경하는 간단한 예이다.

```rust, editable
// 인수의 값에 2를 곱해 반환하는 함수 (1)
fn x2(arg: &mut i32) {
    *arg = *arg * 2;
}

fn main() {
    let mut v = 16;
    x2(&mut v);  // 인수에 2가 곱해진다 (2)
    println!("{}", v);
}
```

컴파일 후 실행해보면 원래 16이었던 `v`의 값이 2배가 되어 32가 출력된다.

프로그램을 확인해보자. (1)은 인수로 전달된 값에 2를 곱하는 함수다. 여기서 중요한 점은 가변 참조자를 이용할 수 있도록 인수 타입 앞에 `&mut`을 붙이는 것이다.

(2)에서는 함수를 호출한다. 이 함수에 전달하는 인수는 가변 참조자여야 하기 때문에 `&mut`을 붙인다.

### 참조 호출과 값 호출의 차이

함수를 호출할 때 인수를 어떻게 전달하느냐에 따라 값 호출(Call by Value)와 참조 호출(Call by Reference)로 나뉜다. 러스트뿐 아니라 다른 일반적인 프로그래밍 언어에서도 이 두 가지 방법이
사용된다.

값 호출은 값 그 자체를 인수로 전달하는 것이며 참조 호출은 변수의 참조자를 사용하는 것이다.

함수를 호출할 때 '값 전달'이 이루어지면 함수의 인수로 지정된 '값'이 그대로 전달되는 것이 아니라 값이 복사되어 함수로 전달된다. 그러므로 함수 안에서 그 값이 어떻게 가공이 되더라도 변수를 호출한 곳에서는
아무런 영향을 받지 않는다. 즉 안전하다. 물론 함수의 인수로 변수를 지정했을 때도 전달되는 것은 변수가 아니라 변수 '값'의 사본이기 때문에 호출한 곳의 변수는 영향을 받지 않는다.

반면 '참조 호출'은 참조자(변수가 가리키는 주소)가 전달된다. 이 경우 함수 안에서 인수의 내용을 변경하면 함수를 호출한 곳의 값도 바뀐다.

러스트에서 참조 전달을 하는 경우 함수의 인수에 참조를 나타내는 `&`를 지정한다. 러스트에서 값 전달을 하는 경우 소유권 시스템의 규칙이 적용된다. 즉 기본 타입(또는 `Copy`트레잇이 구현된 타입)이라면 값이
복사되지만 그 외의 타입에서는 소유권이 이동한다.

> #### println! 매크로 사용 방법 정리
>
> `println!`은 표준 출력으로 임의의 서식을 가진 문자열을 출력하는 매크로다. 러스트 프로그래밍을 하는 데 있어 가장 자주 사용하는 기능 중 하나다. 여기서는 `println!`매크로 사용 방법을
> 정리해본다.
>
> **소유권 문제가 발생하지 않는다.**
>
> `println!`매크로는 소유권과 관련된 문제가 발생하지 않게 구현되어 있다. 다음은 `println!`을 모방해 `echo`함수를 만들어 사용하는 예이다. 하지만 이 함수는 소유권이 이동하기 때문에 에러가
> 발생한다.
>
> ```rust, noplayground
> fn main() {
>     let s = "Fast and Robust".to_string();
>     echo(s);  // <- 소유권이 이동한다.
>     println!("{}", s);
> }
> 
> // println!을 모방한 함수
> fn echo(s: String) {
>     println!("{}", s);
> }
> ```
>
> 컴파일을 해보면 소유권과 관련된 에러가 발생한다. 하지만 `println!`매크로를 이용하면 문제가 없으며, 다음과 같이 몇 번이나 같은 값을 이용할 수 있다.
>
> ```rust, editable
> fn main() {
>     let s = "Fast and Robust".to_string();
>     println!("{}", s);  // 소유권이 이동하지 않는다.
>     println!("{}", s);
> }
> ```
>
> **값을 임의의 장소에 넣을 수 있다.**
>
> 변수나 값을 문자열 안의 임의의 장소에 넣을 수 있다. 그리고 값을 순서대로 채워넣는 것이 아니라 `...{2}...{1}...{0}...`과 같이 순서를 임의로 지정할 수도 있다.
>
> 예를 들어 연도 표시 방법은 나라에 따라 상이하다. 미국에서는 '월/일/년' 순으로 쓰지만 영국에서는 '일/월/년' 순으로 쓴다. 인수 순서는 변경하지 않고 서식만 변경해서 이런 문제에 대응할 수 있다.
>
> ```rust, editable
> fn main() {
>     let year = 2023;
>     let month = 12;
>     let day = 1;
>     println!("KR:{0}/{1}/{2}", year, month, day);  // 한국
>     println!("US:{1}/{2}/{0}", year, month, day);  // 미국
>     println!("UK:{2}/{1}/{0}", year, month, day);  // 영국
> }
> ```
>
> 그리고 다음과 같이 인수에 이름을 붙여서 대입하는 것도 가능하다.
>
> ```rust, editable
> fn main() {
>     let year = 2023;
>     let month = 12;
>     let day = 1;
>     println!("{yy}년 {mm}월 {dd}일", dd = day, mm = month, yy = year);
> }
> ```
>
> **서식(format)을 지정할 수 있다.**

| 서식       | 설명                  | 사용 예       | 입력      | 결과                        |
|----------|---------------------|------------|---------|---------------------------|
| `{:<n}`  | n자리 왼쪽 정렬           | `_{:<5}_`  | 30      | _30   _                   |
| `{:>n}`  | n자리 오른쪽 정렬          | `_{:>5}_`  | 30      | _   30_                   |
| `{:^n}`  | n자리 가운데 정렬          | `_{:5}_`   | 3       | _  3  _                   |
| `{:0<n}` | n자리 왼쪽 정렬 후 0으로 채움  | `_{:0<5}_` | 12      | _12000_                   |
| `{:>0n}` | n자리 오른쪽 정렬 후 0으로 채움 | `_{:>05}_` | 12      | _00012_                   |
| `{:b}`   | 2진수                 | `{:b}`     | 4       | 100                       |
| `{:0nb}` | 2진수에서 n만큼 0으로 채움    | `{:08b}`   | 4       | 00000100                  |
| `{:o}`   | 8진법                 | `{:o}`     | 438     | 666                       |
| `{:x}`   | 16진수                | `{:x}`     | 255     | ff                        |
| `{:0nx}` | 16진수에서 n만큼 0으로 채움   | `{:04x}`   | 15      | 000f                      |
| `{:.n}`  | 소수점 이하 n자리 표시       | `{:.2}`    | 3.1415  | 3.14                      |
| `{:e}`   | 지수 표시               | `{:e}`     | 12.34   | 1.234e1                   |
| `{:?}`   | 디버그 출력              | `{:?}`     | [1,2,3] | [1, 2, 3]                 |
| `{:#?}`  | 디버그 출력(형태 정렬)       | `{:#?}`    | [1,2]   | [(줄바꿈) 1, (줄바꿈) 2, (줄바꿈)] |
| `{{`     | {를 출력               | `{{`       | 없음      | {                         |
| `}}`     | }를 출력               | `}}`       | 없음      | }                         |
| `{:p}`   | 포인터                 | `{:p}`     | abc     | (예)0x1022c2970            |
| `\"`     | "를 출력               | `\"`       | 없음      | "                         |
| `\\`     | \를 출력               | `\\`       | 없음      | \                         |

> 서식을 이용해 보자.
>
> ```rust, editable
> fn main() {
>     // 오른쪽 정렬 및 16진수 출력
>     println!("|{:>8}| #{:06x}", "red", 0xFF0000);
>     println!("|{:>8}| #{:06x}", "green", 0x00FF00);
>     println!("|{:>8}| #{:06x}", "blue", 0x0000FF);
> 
>     // 디버그 출력
>     println!("|{:>8}| RGB{:?}", "yellow", (255, 255, 0));
> }
> ```
>
> 이렇게 `println!`은 다양한 표현을 할 수 있으므로 활용도가 높다. `println!`은 표준 출력 용도이지만 문자열을 출력하지 않고 `String`타입으로 만들어 주는 `format!`매크로도
> 있다. `format!`매크로 역시 `println!`매크로와 사용 방법은 동일하다. `format!`매크로 역시 활용도가 높으므로 사용법을 잘 익혀두자.
