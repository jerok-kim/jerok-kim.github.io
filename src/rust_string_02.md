#패스트캠퍼스, #국비지원교육, #메가바이트스쿨, #MegabyteSchool, #개발자취업부트캠프, #내일배움카드

*last edited 2023.02.03*

# 러스트의 문자열 처리에 익숙해지기

> ▶ 만들면서 배우는 러스트 프로그래밍 -쿠지라 히코우즈쿠에- ◀ 을 참조하여 정리하였다.

앞 섹션에서는 `String`와 `&str`을 이용한 기본적인 문자열 처리를 다뤘다. 이 섹션에서는 앞에서 배운 내용을 바탕으로 조금 더 실용적인 문자열 처리 방법을 알아보자.

## 문자열을 바이너리 에디터 형태로 출력하기

먼저 문자열을 바이너리 편집기에서처럼 출력하는 프로그램을 만들어보자. 지정한 문자열을 16진수로 변환해 4바이트씩 끊어 출력하는 것이다.

```rust, editable
fn main() {
    hex_dump("성공하는 사람은 송곳처럼 어느 한 점을 향하여 일한다.");
}

fn hex_dump(s: &str) {
    // 1바이트씩 표시 (1)
    for (i, c) in s.bytes().enumerate() {
        // 주소를 표시
        if i % 16 == 0 {
            print!("{:08x}|", i);
        }
        
        // 4자리씩 끊어 문자를 표시
        if i % 4 == 3 {
            print!("{:02x}}", c);
        } else {
            print!("{:02x} ", c);
        }
        
        // 16바이트마다 줄바꿈
        if i % 16 == 15 {
            println!();
        }
    }
    
    println!();
}
```

컴파일 후 실행해보면 문자열을 1바이트씩 잘라 한 줄에 16바이트의 16진수 데이터를 출력한다.

앞 섹션에서 설명한 것처럼 `&str` 타입의 `bytes` 메서드는 UTF-8 문자열을 1바이트씩 자른 반복자를 반환한다. 반복자에 `enumerate` 메서드를 이용하면 반복자에 인덱스를 붙인 데이터를 반환한다.

## 부분 문자열 얻기

문자열에서 부분 문자열을 추출하는 방법을 살펴보자. 문자열 처리를 할 때 부분 문자열만을 이용하는 경우는 자주 일어난다.

부분 문자열을 얻는 방법은 다양하지만 가장 간단한 슬라이스를 이용한 방법은 다음과 같이 생각할 수 있다.

```rust, editable
fn main() {
    let pr = "지혜는 무기보다 가치가 있다.";

    // 앞의 2글자(6바이트)를 얻기 (1)
    println!("앞 2글자: {}", &pr[0..6]);

    // '무기' 부분을 얻기 (2)
    println!("4-5번째 글자: {}", &pr[10..16]);
}
```

1. 문장의 제일 앞 2글자를 가져와 출력한다. `&str`의 슬라이스는 문자열이 아니라 바이트를 지정한다. 앞에서 설명한 것처럼 한글은 1글자당 3바이트다. 따라서 `&pr[0..6]`으로 6바이트까지의 데이터를
   지정한다.
2. 여기서는 약간 다른데, 공백이 한 칸 들어있으므로 `9..15`가 아니라 `10..16`이 된다. 공백은 영어나 숫자와 같이 1바이트이기 때문이다.

현재 프로그램에는 문제가 있다. 띄어쓰기는 1바이트가 사용되므로 문장이 변경되는 경우 어디에서 띄어쓰기가 발생하느냐에 따라 제대로 처리가 안 될 수 있다. 그리고 이모지의 경우 3~4바이트를 이용하므로 역시 문제가
발생할 가능성이 있다.

| 문자 종류        | 예                    | 바이트    |
|--------------|----------------------|--------|
| 영어, 숫자, 특수문자 | a / b / A / #        | 1바이트   |
| 한국어          | 가 / 양 / 화            | 3바이트   |
| 일본어(가나 / 한자) | あ / ン / 愛            | 3바이트   |
| 이모지          | 🦀/ 😆 / ⚡ / 🛡 / 🐘 | 3~4바이트 |

### 슬라이스에서 잘못된 범위를 지정한 경우

문자 범위 지정이 잘못됐다면 프로그램은 패닉 에러가 발생해 강제로 종료된다.

다음은 범위를 잘못 지정한 예다.

```rust, editable
fn main() {
    let pr = "🦀😆⚡🛡🐘";
    
    // 앞의 2글자(6바이트)를 얻기 (1)
    println!("앞 2글자: {}", &pr[0..6]);
}
```

컴파일은 문제없이 완료되지만 프로그램을 실행하면 패닉 에러가 발생하고 종료된다.

그렇다면 어떻게 문자열의 일부분을 취득해야 할까?

### chars와 enumberate를 이용해 부분 문자열을 얻는 방법

간단한 해결 방법은 `chars` 메서드를 이용해 문자 단위로 다루는 것이다. 다음은 `enumerate` 메서드를 이용해 인덱스를 만들어 문자열을 취득하는 예다.

```rust, editable
fn main() {
    pr = "🦀😆⚡🛡🐘";

    // 앞의 2글자를 얻기 (1)
    let mut sub1 = String::new();
    for (i, c) in pr.chars().enumerate() {
        if i < 2 {
            sub1.push(c);
            continue;
        }
        break;
    }
    println!("앞 2글자: {}", sub1);

    // '🦀😆' 부분 얻기 (2)
    let mut sub2 = String::new();
    for (i, c) in pr.chars().enumerate() {
        if 3 <= i && i <= 4 {
            sub2.push(c);
        }
        println!("4-5번째 문자: {}", sub2);
    }
}
```

이번에는 문제없이 실행된다.

1. 앞의 2글자를 얻는다. `enumerate` 메서드를 사용하면 `char` 데이터와 몇 번째 문자인지를 나타내는 인덱스를 얻을 수 있다. 이 인덱스(변수 `i`)를 확인해 2 미만이면 부분 문자열을 저장할
   변수 `sub1`에 1문자씩 추가한다. `String` 타입의 `push`메서드를 이용하면 `char`타입 문자를 추가할 수 있다.
2. 마찬가지 방법을 사용한다. 여기서는 4~5번째 문자를 얻어와야 하므로 `for` 문 안에 있는 `if` 조건이 바뀐다. 조건에 맞는 위치에 존재하는 문자를 변수 `sub2`에 추가한다.

### 조금 더 영리하게 부분 문자열 얻기

`enumerate` 메서드를 사용하는 방법도 나쁘지는 않지만 `for` 문을 이용해 반복해야 하며, 코드가 중복된다. 이번에는 조금 더 영리한 방법을 2가지 소개한다. 2가지 다 문자열을 문자 단위로
조작하므로 `chars` 메서드를 이용한다.

```rust, editable
fn main() {
    let pr = "지혜는 무기보다 가치가 있다.";

    // 앞의 2글자 부분 문자열 얻기 (1)
    let sub3: String = pr.chars().take(2).collect();
    println!("앞 2글자: {}", sub3);

    // '무기' 부분 문자열 얻기 (2)
    let pr_chars: Vec<char> = pr.chars().collect();  // 변환

    // 4-5번째 문자열 얻기
    let sub_chars = &pr_chars[4..=5];  // 슬라이스

    // 슬라이스를 문자열로 변환
    let sub4: String = sub_chars.into_iter().collect();
    println!("4-5번째 글자: {}", sub4);
}
```

실행해보면 '지혜', '무기'가 출력되는 것을 확인할 수 있다.

1. 앞의 2글자를 부분 문자열로 가져와 출력한다. `&str`의 `chars`메서드는 반복자를 반환하므로 여기서 `take(2)`라고 지정하면 앞의 2글자를 가져올 수 있다. 변수는 아직 반복자
   상태이므로 `collect` 메서드를 이용해 문자열로 변환한다. `take` 메서드를 이용해 짧은 코드로 처리를 할 수 있었다. `take`는 반복자에서 지정한 개수만큼의 데이터를 불러오므로 데이터 일부를
   가져오는 데 유용하다.
2. '무기' 부분의 문자열을 가져오기 위해 5번째와 6번째 문자열을 가져온다. 공백도 하나의 문자로 카운트되기 때문에 5번째 글자가 '무'가 된다. `&str` 데이터를 `Vec<char>`로 변환한
   뒤 `&pr_chars[4..=5]`와 같이 슬라이스해 데이터를 가져온다. 이 때의 데이터는 ['무', '기']가 되므로 `into_iter().collect`메서드를 이용해 `String`으로 변환한다.
   여기서 중요한 부분은 `Vec<char>`로 변환하는 것이다. 이렇게 해서 문자 단위로 조작할 수 있다. 그리고 `Vec<char>`의 슬라이스를 문자열로 변환하는 방법도 잘 기억해두자.
   참고로 `&pr_char[4..=5]`는 `&pr_char[4..6]`으로 써도 같은 의미다.

## 문자열 검색

다음으로 `&str` 타입 문자열을 검색해보자. `find` 메서드를 이용하면 검색을 할 수 있다. 다음은 문자열 안에서 '귤'(`char` 타입)이라는 글자가 어디에 있는지, 그리고 '바나나'(`&str` 타입)
라는 단어가 어디에 있는지 검색하는 예다.

```rust, editable
fn main() {
    let s = "제주도의 특산품 중 귤은 겨울에 많이 먹을 수 있다.";

    // '귤'을 검색 (1)
    match s.find('귤') {
        Some(i) => println!("귤 = {}B", i),
        None => println!("'귤'이라는 단어는 없습니다."),
    };

    // "바나나"를 검색 (2)
    match s.find("바나나") {
        Some(i) => println!("바나나 = {}B", i),
        None => println!("'바나나'라는 단어는 없습니다."),
    };
}
```

컴파일 후 실행해보면 '귤'이라는 글자가 어디에 있는지 표시해준다.

1. `find` 메서드를 이용해 '귤'(`char` 타입)이 어디에 있는지 검색한다. `find` 메서드는 `Option` 타입이므로 `Some(위치)` 또는 `None`을 반환한다. 그래서 `match`문을
   이용해 처리한다. `Some(위치)`는 해당 글자가 위치한 곳의 '바이트-1'을 반환한다(배열과 같이 0바이트에서 시작한다). 즉 '제'라는 문자를 검색하면 `Some(0)`이 반환된다.
2. `find`를 이용해 '바나나'(`&str` 타입)를 검색한다. 문자열에 '바나나'가 포함되지 않았으므로 `None`이 반환된다.

### 클로저를 지정한 검색

`find` 메서드에서는 클로저를 지정할 수도 있다. 영단어 등을 검색할 때 알파벳을 모두 소문자로 변경해 대소문자를 신경 쓰지 않고도 검색이 되게 하는 등 유연한 검색 기능을 만들 수 있다.

다음은 문자열을 대문자로 변환한 뒤 검색해 가장 처음에 나오는 'S'의 위치를 찾는 예다.

```rust, editable
fn main() {
    // 변수 s에 문장을 대입
    let s = format!("{}{}",
                    "There is more hapiness in giving ",
                    "than there is in receiving.");

    // 클로저로 검색
    let res = s.find(|c: char| c.to_ascii_uppercase() == 'S');
    match res {
        Some(i) => println!("S={}B", i),
        None => println!("None"),
    };
}
```

컴파일 후 실행해보면 영어 문장에서 가장 처음 'S'가 등장하는 위치가 표시된다.

1. `format!` 매크로를 이용해 두 문장을 하나로 합쳤다. 큰따옴표로 둘러싸인 문자열 리터럴은 모두 `&str`이므로 `+` 연산자로는 결합할 수 없지만 `format!` 매크로를 이용하면 쉽게 결합할 수
   있다.
2. `find` 메서드에 클로저를 이용해 검색한다. 여기서 클로저에 '문장에 있는 알파벳을 대문자로 바꿔서 S가 되는 것'을 찾는다는 조건을 넣었다. 이처럼 `find` 메서드에 클로저를 이용하면 `for`
   문이나 `if`문을 조합하지 않고도 쉽게 검색할 수 있다.

### 문자열 치환

다음으로 문자열 치환에 도전해보자. 문자열에서 1문자만 치환하려면 `replace` 메서드를 이용한다.

다음은 문자열 치환 예다. 원래 문장에서 2곳을 치환한다.

```rust, editable
fn main() {
    let s = "내 자신에 대한 자신감을 잃으면 온 세상이 나의 적이 된다.";

    // 문자열 치환 (1)
    let s2 = s.replace("잃으면", "가지면");
    let s3 = s.replace("적이", "편이");

    // 치환 전과 후를 출력 (2)
    println!("수정 전 : {}\n수정 후 : {}", s, s3);
}
```

1. `&str`의 `replace`메서드를 이용해 문자열의 일부를 치환한다. 그리고 (2) 부분에서는 치환 전과 치환 후의 문자열을 출력한다.

`&str` 타입은 값을 변경할 수 없으므로 치환한 후의 문자열은 `String` 타입이 된다. 즉, `s2`와 `s3`은 `String` 타입이다. 여기서 알 수 있듯 `&str` 타입과 `String` 타입
모두 `replace` 메서드를 사용할 수 있다.

## 섀도잉 - 스코프 안에서 변수 재선언

앞의 예에서 치환 후의 문자열만 사용한다면 치환할 때마다 변수를 다시 선언하는 것은 비효율적이다. 러스트에서는 섀도잉(Shadowing)이라는 기능이 있어 같은 스코프 안에서 이전에 선언한 변수와 같은 이름의 새
변수를 선언할 수 있다. 같은 이름을 가진 변수를 선언하면 이전에 선언한 변수의 값이 숨겨지고(shadowed) 새로 선언된 변수의 값을 갖게 된다.

다음은 앞 예제에서 섀도잉을 이용해 변수 이름을 바꾸지 않고 값을 바꾸는 예다.

```rust, editable
fn main() {
    let s = "내 자신에 대한 자신감을 잃으면 온 세상이 나의 적이 된다.";
    let s = s.replace("잃으면", "가지면");
    let s = s.replace("적이", "편이");
    println!("{}", s);
}
```

프로그램을 실행해보자. 섀도잉으로 인해 같은 이름의 변수를 여러 번 사용했지만 문제없이 실행되는 것을 알 수 있다.

섀도잉을 이용하면 잠시 사용하기 위한 변수를 만드는 수고를 덜 수 있다. 그리고 가변 변수를 이용하는 부분을 줄일 수도 있다.

예를 들어 변수 `v`에 덧셈을 한 번 하기 위해 `v`를 가변 변수로 선언하는 것은 좋은 생각은 아니다. 이럴 때 섀도잉을 이용하면 불필요한 가변 변수를 쓰지 않고도 해결할 수 있다.

```rust, editable
fn main() {
    // 섀도잉을 이용하지 않음 (1)
    {
        let mut v = 300;  // v를 가변 변수로 선언
        v = v + 5;
        println!("{}", v);
    }

    // 섀도잉을 이용 (2)
    {
        let v = 300;  // v는 불변 변수
        let v = v + 5;
        println!("{}", v);
    }
}
```

1. 변수 `v`를 가변 변수로 선언했다. 덧셈 한 번을 위해 가변 변수를 선언하면 나중에 실수로 `v`의 값을 변경하는 등 버그의 원인이 될 수 있다.
2. 섀도잉을 이용하므로 불변 변수를 이용해도 문제가 없다. 섀도잉을 하면 섀도잉 전의 값은 이용할 수 없지만 변수는 여전히 불변이므로 안전하다.

## 문자열 분할

문자열을 자를 때는 특정 위치에서 자르거나 구분자로 사용할 문자로 자를 수 있다.

다음은 전화번호 031-943-2839에서 지역번호 031을 제외한 '943-2839'을 국번과 사번으로 나누는 예다. 슬라이스를 제외하고 3가지 메서드를 이용해 분할한다.

```rust, editable
fn main() {
    // 전화번호 지정
    let telno = "943-2839";

    // 슬라이스로 분할 (1)
    println!("-- 슬라이스 --");
    println!("국번: {}", &telno[..3]);
    println!("사번: {}", &telno[4..]);

    // split_at으로 분할 (2)
    println!("--- split_at ---");
    let (telno1, telno2) = telno.split_at(3);
    let (telno2, telno3) = telno2.split_at(1);
    println!("국번: {}", telno1);
    println!("구분: {}", telno2);
    println!("사번: {}", telno3);

    // split_off로 분할 (3)
    println!("-- split_off --");
    let mut telno1 = String::from(telno);
    let mut telno2 = telno1.split_off(3);
    let telno3 = telno2.split_off(1);
    println!("국번: {}", telno1);
    println!("구분: {}", telno2);
    println!("사번: {}", telno3);

    // split으로 분할 (4)
    println!("-- split --");
    let telno_a: Vec<&str> = telno.split('-').collect();
    println!("국번: {}", telno_a[0]);
    println!("사번: {}", telno_a[1]);
}
```

컴파일 후 실행해보면 국번과 사번이 나뉘어 출력되는 것을 확인할 수 있다.

1. 슬라이스를 이용한 분할이다. 직접 범위를 지정해 추출한다.
2. `split_at` 메서드를 이용한다. 임의의 위치를 지정해 해당 위치를 기준으로 문자열을 분리해 튜플 `(&str, &str)` 타입을 반환한다.
3. `split_off` 메서드를 이용한 방법이다. `split_off`를 이용하면 인수로 지정한 바이트 수를 남겨 그 값을 반환한다. 먼저 첫 변수 `telno1`에 `String::from`을 이용해 전화번호
   문자열을 대입한다. 그리고 `telno1.split_off(3)`을 하면 처음 3바이트인 943가 `telno1`에 남고 나머지 (-2839) 부분은 `telno2`에 대입된다.
   그리고 `telno2.split_off(1)`로 `telno2`에 하이픈(`-`)을 남기고 `telno3`에 나머지 부분인 2839가 대입된다.
4. `split` 메서드를 이용하는 방법이다. `split` 메서드는 구분할 기준 문자를 지정하면 해당 문자를 기준으로 문자열이 분리된다. `split` 메서드는 `Vec<&str>` 타입을 반환한다. 이 메서드는
   구분자는 출력하지 않는다.

## EUC-KR로 인코딩된 파일 읽고 쓰기

러스트는 UTF-8을 이용해 문자열을 처리하므로 EUC-KR 같이 UTF-8로 인코딩되지 않은 파일을 다루기 위해서는 변환 작업을 해야 한다. 지금은 대부분 UTF-8을 이용하지만, 예전 버전 윈도우에서는 별도로
지정하지 않는 이상 EUC-KR 인코딩으로 저장된다. 여기서는 EUC-KR 문서를 다루기 위해 `encoding_rs`라는 크레이트를 이용한다.

```rust
use encoding_rs;
use std::fs;
use std::fs::File;
use std::io::Write;

fn main() {
    // 저장할 파일 이름 지정
    let filename = "test-euckr.txt";

    // EUC_KR로 저장 (1)
    save_euckr(filename, "맛있게 먹으면 0칼로리");

    // EUC_KR 파일 읽어오기 (2)
    let s = load_euckr(filename);
    println!("{}", s);
}

fn save_euckr(filename: &str, text: &str) {
    // EUC_KR로 인코드 (3)
    let (enc, _, _) = encoding_rs::EUC_KR.encode(text);
    let buf = enc.into_owned();

    // 파일 생성 및 내용 쓰기 (4)
    let mut file = File::create(filename).expect("생성");
    file.write(&buf[..]).expect("쓰기");
}

fn load_euckr(filename: &str) -> String {
    // 파일을 한 번에 읽어들임 (5)
    let buf = fs::read(filename).expect("읽기");

    // EUC_KR로 디코드 (6)
    let (dec, _, _) = encoding_rs::EUC_KR.decode(&buf);
    dec.into_owned()
}
```

프로그램을 빌드한 뒤 실행해보면, 파일이 하나 생성되고 파일의 내용이 출력된다. 실행 전에는 없던 `test-euckr.txt` 파일이 생성된 것을 확인할 수 있다.

```text
$ cargo run
   Compiling cfg-if v1.0.0
   Compiling encoding_rs v0.8.31                                                                                                                                                                                                  
   Compiling enc_save_load v0.1.0 (C:\Users\jerok\projects\rust\rust_programming_examples\src\ch03\enc_save_load)                                                                                                                 
    Finished dev [unoptimized + debuginfo] target(s) in 3.06s                                                                                                                                                                     
     Running `target\debug\enc_save_load.exe`
맛있게 먹으면 0칼로리
```

소스 코드의 (1)과 (2)는 지정한 파일 이름으로 저장하는 함수와 저장된 파일을 불러오는 함수를 호출하는 부분이다.

3. 러스트이 문자열을 EUC-KR로 인코딩한다. `encoding_rs`는 다양한 언어로 인코딩을 할 수 있다. `encode` 메서드를 이용해 인코딩을 하면 `(Cow<[u8]> Encoding, bool)`
   형태의 튜플을 반환한다. 이 중 `Cow<[u8]>`은 EUC-KR로 인코딩된 바이너리 배열 슬라이스다. `Cow`는 데이터 참조와 소유가 모두 가능한 객체다. `into_owned` 메서드를 호출해 소유권을
   가져올 수 있다.
4. 바이너리 배열을 파일로 저장한다. `File::create`로 파일을 생성하고 `file.write`를 이용해 데이터를 파일에 쓴다. `create`와 `write` 메서드에 `expect`를 지정해 작업이
   실패하면 어느 부분에서 에러가 발생했는지 바로 알 수 있게 했다.
5. `fs::read`를 이용해 파일에서 바이트 배열을 읽는다.
6. EUC-KR의 `decode` 메서드를 이용해 바이너리 배열을 UTF-8로 디코드한다. `decode`의 반환값은 `(Cow<str>, Encoding, bool)` 형태의 튜플이다. `Cow<str>`
   에 `into_owned`메서드를 이용해 소유권을 획득하면 `String` 타입 문자열을 얻을 수 있다.
