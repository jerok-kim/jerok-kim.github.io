<!DOCTYPE HTML>
<html lang="kr" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>러스트의 문자열 처리에 익숙해지기 - Fast⚡ and Robust🛡️</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="home.html">Home</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">토막글</li><li class="chapter-item expanded "><a href="rust.html"><strong aria-hidden="true">1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust_ownership.html"><strong aria-hidden="true">1.1.</strong> 소유권 시스템</a></li><li class="chapter-item expanded "><a href="rust_borrowing.html"><strong aria-hidden="true">1.2.</strong> 빌림과 참조</a></li><li class="chapter-item expanded "><a href="rust_string.html"><strong aria-hidden="true">1.3.</strong> 러스트의 문자열</a></li><li class="chapter-item expanded "><a href="rust_string_02.html" class="active"><strong aria-hidden="true">1.4.</strong> 러스트의 문자열 처리에 익숙해지기</a></li><li class="chapter-item expanded "><a href="trait.html"><strong aria-hidden="true">1.5.</strong> 공통 동작을 정의하는 트레잇</a></li><li class="spacer"></li><li class="spacer"></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fast⚡ and Robust🛡️</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jerok-kim/jerok-kim.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>#패스트캠퍼스, #국비지원교육, #메가바이트스쿨, #MegabyteSchool, #개발자취업부트캠프, #내일배움카드</p>
<p><em>last edited 2023.02.03</em></p>
<h1 id="러스트의-문자열-처리에-익숙해지기"><a class="header" href="#러스트의-문자열-처리에-익숙해지기">러스트의 문자열 처리에 익숙해지기</a></h1>
<blockquote>
<p>▶ 만들면서 배우는 러스트 프로그래밍 -쿠지라 히코우즈쿠에- ◀ 을 참조하여 정리하였다.</p>
</blockquote>
<p>앞 섹션에서는 <code>String</code>와 <code>&amp;str</code>을 이용한 기본적인 문자열 처리를 다뤘다. 이 섹션에서는 앞에서 배운 내용을 바탕으로 조금 더 실용적인 문자열 처리 방법을 알아보자.</p>
<h2 id="문자열을-바이너리-에디터-형태로-출력하기"><a class="header" href="#문자열을-바이너리-에디터-형태로-출력하기">문자열을 바이너리 에디터 형태로 출력하기</a></h2>
<p>먼저 문자열을 바이너리 편집기에서처럼 출력하는 프로그램을 만들어보자. 지정한 문자열을 16진수로 변환해 4바이트씩 끊어 출력하는 것이다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    hex_dump(&quot;성공하는 사람은 송곳처럼 어느 한 점을 향하여 일한다.&quot;);
}

fn hex_dump(s: &amp;str) {
    // 1바이트씩 표시 (1)
    for (i, c) in s.bytes().enumerate() {
        // 주소를 표시
        if i % 16 == 0 {
            print!(&quot;{:08x}|&quot;, i);
        }
        
        // 4자리씩 끊어 문자를 표시
        if i % 4 == 3 {
            print!(&quot;{:02x}}&quot;, c);
        } else {
            print!(&quot;{:02x} &quot;, c);
        }
        
        // 16바이트마다 줄바꿈
        if i % 16 == 15 {
            println!();
        }
    }
    
    println!();
}</code></pre></pre>
<p>컴파일 후 실행해보면 문자열을 1바이트씩 잘라 한 줄에 16바이트의 16진수 데이터를 출력한다.</p>
<p>앞 섹션에서 설명한 것처럼 <code>&amp;str</code> 타입의 <code>bytes</code> 메서드는 UTF-8 문자열을 1바이트씩 자른 반복자를 반환한다. 반복자에 <code>enumerate</code> 메서드를 이용하면 반복자에 인덱스를 붙인 데이터를 반환한다.</p>
<h2 id="부분-문자열-얻기"><a class="header" href="#부분-문자열-얻기">부분 문자열 얻기</a></h2>
<p>문자열에서 부분 문자열을 추출하는 방법을 살펴보자. 문자열 처리를 할 때 부분 문자열만을 이용하는 경우는 자주 일어난다.</p>
<p>부분 문자열을 얻는 방법은 다양하지만 가장 간단한 슬라이스를 이용한 방법은 다음과 같이 생각할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let pr = &quot;지혜는 무기보다 가치가 있다.&quot;;

    // 앞의 2글자(6바이트)를 얻기 (1)
    println!(&quot;앞 2글자: {}&quot;, &amp;pr[0..6]);

    // '무기' 부분을 얻기 (2)
    println!(&quot;4-5번째 글자: {}&quot;, &amp;pr[10..16]);
}</code></pre></pre>
<ol>
<li>문장의 제일 앞 2글자를 가져와 출력한다. <code>&amp;str</code>의 슬라이스는 문자열이 아니라 바이트를 지정한다. 앞에서 설명한 것처럼 한글은 1글자당 3바이트다. 따라서 <code>&amp;pr[0..6]</code>으로 6바이트까지의 데이터를
지정한다.</li>
<li>여기서는 약간 다른데, 공백이 한 칸 들어있으므로 <code>9..15</code>가 아니라 <code>10..16</code>이 된다. 공백은 영어나 숫자와 같이 1바이트이기 때문이다.</li>
</ol>
<p>현재 프로그램에는 문제가 있다. 띄어쓰기는 1바이트가 사용되므로 문장이 변경되는 경우 어디에서 띄어쓰기가 발생하느냐에 따라 제대로 처리가 안 될 수 있다. 그리고 이모지의 경우 3~4바이트를 이용하므로 역시 문제가
발생할 가능성이 있다.</p>
<div class="table-wrapper"><table><thead><tr><th>문자 종류</th><th>예</th><th>바이트</th></tr></thead><tbody>
<tr><td>영어, 숫자, 특수문자</td><td>a / b / A / #</td><td>1바이트</td></tr>
<tr><td>한국어</td><td>가 / 양 / 화</td><td>3바이트</td></tr>
<tr><td>일본어(가나 / 한자)</td><td>あ / ン / 愛</td><td>3바이트</td></tr>
<tr><td>이모지</td><td>🦀/ 😆 / ⚡ / 🛡 / 🐘</td><td>3~4바이트</td></tr>
</tbody></table>
</div>
<h3 id="슬라이스에서-잘못된-범위를-지정한-경우"><a class="header" href="#슬라이스에서-잘못된-범위를-지정한-경우">슬라이스에서 잘못된 범위를 지정한 경우</a></h3>
<p>문자 범위 지정이 잘못됐다면 프로그램은 패닉 에러가 발생해 강제로 종료된다.</p>
<p>다음은 범위를 잘못 지정한 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let pr = &quot;🦀😆⚡🛡🐘&quot;;
    
    // 앞의 2글자(6바이트)를 얻기 (1)
    println!(&quot;앞 2글자: {}&quot;, &amp;pr[0..6]);
}</code></pre></pre>
<p>컴파일은 문제없이 완료되지만 프로그램을 실행하면 패닉 에러가 발생하고 종료된다.</p>
<p>그렇다면 어떻게 문자열의 일부분을 취득해야 할까?</p>
<h3 id="chars와-enumberate를-이용해-부분-문자열을-얻는-방법"><a class="header" href="#chars와-enumberate를-이용해-부분-문자열을-얻는-방법">chars와 enumberate를 이용해 부분 문자열을 얻는 방법</a></h3>
<p>간단한 해결 방법은 <code>chars</code> 메서드를 이용해 문자 단위로 다루는 것이다. 다음은 <code>enumerate</code> 메서드를 이용해 인덱스를 만들어 문자열을 취득하는 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    pr = &quot;🦀😆⚡🛡🐘&quot;;

    // 앞의 2글자를 얻기 (1)
    let mut sub1 = String::new();
    for (i, c) in pr.chars().enumerate() {
        if i &lt; 2 {
            sub1.push(c);
            continue;
        }
        break;
    }
    println!(&quot;앞 2글자: {}&quot;, sub1);

    // '🦀😆' 부분 얻기 (2)
    let mut sub2 = String::new();
    for (i, c) in pr.chars().enumerate() {
        if 3 &lt;= i &amp;&amp; i &lt;= 4 {
            sub2.push(c);
        }
        println!(&quot;4-5번째 문자: {}&quot;, sub2);
    }
}</code></pre></pre>
<p>이번에는 문제없이 실행된다.</p>
<ol>
<li>앞의 2글자를 얻는다. <code>enumerate</code> 메서드를 사용하면 <code>char</code> 데이터와 몇 번째 문자인지를 나타내는 인덱스를 얻을 수 있다. 이 인덱스(변수 <code>i</code>)를 확인해 2 미만이면 부분 문자열을 저장할
변수 <code>sub1</code>에 1문자씩 추가한다. <code>String</code> 타입의 <code>push</code>메서드를 이용하면 <code>char</code>타입 문자를 추가할 수 있다.</li>
<li>마찬가지 방법을 사용한다. 여기서는 4~5번째 문자를 얻어와야 하므로 <code>for</code> 문 안에 있는 <code>if</code> 조건이 바뀐다. 조건에 맞는 위치에 존재하는 문자를 변수 <code>sub2</code>에 추가한다.</li>
</ol>
<h3 id="조금-더-영리하게-부분-문자열-얻기"><a class="header" href="#조금-더-영리하게-부분-문자열-얻기">조금 더 영리하게 부분 문자열 얻기</a></h3>
<p><code>enumerate</code> 메서드를 사용하는 방법도 나쁘지는 않지만 <code>for</code> 문을 이용해 반복해야 하며, 코드가 중복된다. 이번에는 조금 더 영리한 방법을 2가지 소개한다. 2가지 다 문자열을 문자 단위로
조작하므로 <code>chars</code> 메서드를 이용한다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let pr = &quot;지혜는 무기보다 가치가 있다.&quot;;

    // 앞의 2글자 부분 문자열 얻기 (1)
    let sub3: String = pr.chars().take(2).collect();
    println!(&quot;앞 2글자: {}&quot;, sub3);

    // '무기' 부분 문자열 얻기 (2)
    let pr_chars: Vec&lt;char&gt; = pr.chars().collect();  // 변환

    // 4-5번째 문자열 얻기
    let sub_chars = &amp;pr_chars[4..=5];  // 슬라이스

    // 슬라이스를 문자열로 변환
    let sub4: String = sub_chars.into_iter().collect();
    println!(&quot;4-5번째 글자: {}&quot;, sub4);
}</code></pre></pre>
<p>실행해보면 '지혜', '무기'가 출력되는 것을 확인할 수 있다.</p>
<ol>
<li>앞의 2글자를 부분 문자열로 가져와 출력한다. <code>&amp;str</code>의 <code>chars</code>메서드는 반복자를 반환하므로 여기서 <code>take(2)</code>라고 지정하면 앞의 2글자를 가져올 수 있다. 변수는 아직 반복자
상태이므로 <code>collect</code> 메서드를 이용해 문자열로 변환한다. <code>take</code> 메서드를 이용해 짧은 코드로 처리를 할 수 있었다. <code>take</code>는 반복자에서 지정한 개수만큼의 데이터를 불러오므로 데이터 일부를
가져오는 데 유용하다.</li>
<li>'무기' 부분의 문자열을 가져오기 위해 5번째와 6번째 문자열을 가져온다. 공백도 하나의 문자로 카운트되기 때문에 5번째 글자가 '무'가 된다. <code>&amp;str</code> 데이터를 <code>Vec&lt;char&gt;</code>로 변환한
뒤 <code>&amp;pr_chars[4..=5]</code>와 같이 슬라이스해 데이터를 가져온다. 이 때의 데이터는 ['무', '기']가 되므로 <code>into_iter().collect</code>메서드를 이용해 <code>String</code>으로 변환한다.
여기서 중요한 부분은 <code>Vec&lt;char&gt;</code>로 변환하는 것이다. 이렇게 해서 문자 단위로 조작할 수 있다. 그리고 <code>Vec&lt;char&gt;</code>의 슬라이스를 문자열로 변환하는 방법도 잘 기억해두자.
참고로 <code>&amp;pr_char[4..=5]</code>는 <code>&amp;pr_char[4..6]</code>으로 써도 같은 의미다.</li>
</ol>
<h2 id="문자열-검색"><a class="header" href="#문자열-검색">문자열 검색</a></h2>
<p>다음으로 <code>&amp;str</code> 타입 문자열을 검색해보자. <code>find</code> 메서드를 이용하면 검색을 할 수 있다. 다음은 문자열 안에서 '귤'(<code>char</code> 타입)이라는 글자가 어디에 있는지, 그리고 '바나나'(<code>&amp;str</code> 타입)
라는 단어가 어디에 있는지 검색하는 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let s = &quot;제주도의 특산품 중 귤은 겨울에 많이 먹을 수 있다.&quot;;

    // '귤'을 검색 (1)
    match s.find('귤') {
        Some(i) =&gt; println!(&quot;귤 = {}B&quot;, i),
        None =&gt; println!(&quot;'귤'이라는 단어는 없습니다.&quot;),
    };

    // &quot;바나나&quot;를 검색 (2)
    match s.find(&quot;바나나&quot;) {
        Some(i) =&gt; println!(&quot;바나나 = {}B&quot;, i),
        None =&gt; println!(&quot;'바나나'라는 단어는 없습니다.&quot;),
    };
}</code></pre></pre>
<p>컴파일 후 실행해보면 '귤'이라는 글자가 어디에 있는지 표시해준다.</p>
<ol>
<li><code>find</code> 메서드를 이용해 '귤'(<code>char</code> 타입)이 어디에 있는지 검색한다. <code>find</code> 메서드는 <code>Option</code> 타입이므로 <code>Some(위치)</code> 또는 <code>None</code>을 반환한다. 그래서 <code>match</code>문을
이용해 처리한다. <code>Some(위치)</code>는 해당 글자가 위치한 곳의 '바이트-1'을 반환한다(배열과 같이 0바이트에서 시작한다). 즉 '제'라는 문자를 검색하면 <code>Some(0)</code>이 반환된다.</li>
<li><code>find</code>를 이용해 '바나나'(<code>&amp;str</code> 타입)를 검색한다. 문자열에 '바나나'가 포함되지 않았으므로 <code>None</code>이 반환된다.</li>
</ol>
<h3 id="클로저를-지정한-검색"><a class="header" href="#클로저를-지정한-검색">클로저를 지정한 검색</a></h3>
<p><code>find</code> 메서드에서는 클로저를 지정할 수도 있다. 영단어 등을 검색할 때 알파벳을 모두 소문자로 변경해 대소문자를 신경 쓰지 않고도 검색이 되게 하는 등 유연한 검색 기능을 만들 수 있다.</p>
<p>다음은 문자열을 대문자로 변환한 뒤 검색해 가장 처음에 나오는 'S'의 위치를 찾는 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 변수 s에 문장을 대입
    let s = format!(&quot;{}{}&quot;,
                    &quot;There is more hapiness in giving &quot;,
                    &quot;than there is in receiving.&quot;);

    // 클로저로 검색
    let res = s.find(|c: char| c.to_ascii_uppercase() == 'S');
    match res {
        Some(i) =&gt; println!(&quot;S={}B&quot;, i),
        None =&gt; println!(&quot;None&quot;),
    };
}</code></pre></pre>
<p>컴파일 후 실행해보면 영어 문장에서 가장 처음 'S'가 등장하는 위치가 표시된다.</p>
<ol>
<li><code>format!</code> 매크로를 이용해 두 문장을 하나로 합쳤다. 큰따옴표로 둘러싸인 문자열 리터럴은 모두 <code>&amp;str</code>이므로 <code>+</code> 연산자로는 결합할 수 없지만 <code>format!</code> 매크로를 이용하면 쉽게 결합할 수
있다.</li>
<li><code>find</code> 메서드에 클로저를 이용해 검색한다. 여기서 클로저에 '문장에 있는 알파벳을 대문자로 바꿔서 S가 되는 것'을 찾는다는 조건을 넣었다. 이처럼 <code>find</code> 메서드에 클로저를 이용하면 <code>for</code>
문이나 <code>if</code>문을 조합하지 않고도 쉽게 검색할 수 있다.</li>
</ol>
<h3 id="문자열-치환"><a class="header" href="#문자열-치환">문자열 치환</a></h3>
<p>다음으로 문자열 치환에 도전해보자. 문자열에서 1문자만 치환하려면 <code>replace</code> 메서드를 이용한다.</p>
<p>다음은 문자열 치환 예다. 원래 문장에서 2곳을 치환한다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let s = &quot;내 자신에 대한 자신감을 잃으면 온 세상이 나의 적이 된다.&quot;;

    // 문자열 치환 (1)
    let s2 = s.replace(&quot;잃으면&quot;, &quot;가지면&quot;);
    let s3 = s.replace(&quot;적이&quot;, &quot;편이&quot;);

    // 치환 전과 후를 출력 (2)
    println!(&quot;수정 전 : {}\n수정 후 : {}&quot;, s, s3);
}</code></pre></pre>
<ol>
<li><code>&amp;str</code>의 <code>replace</code>메서드를 이용해 문자열의 일부를 치환한다. 그리고 (2) 부분에서는 치환 전과 치환 후의 문자열을 출력한다.</li>
</ol>
<p><code>&amp;str</code> 타입은 값을 변경할 수 없으므로 치환한 후의 문자열은 <code>String</code> 타입이 된다. 즉, <code>s2</code>와 <code>s3</code>은 <code>String</code> 타입이다. 여기서 알 수 있듯 <code>&amp;str</code> 타입과 <code>String</code> 타입
모두 <code>replace</code> 메서드를 사용할 수 있다.</p>
<h2 id="섀도잉---스코프-안에서-변수-재선언"><a class="header" href="#섀도잉---스코프-안에서-변수-재선언">섀도잉 - 스코프 안에서 변수 재선언</a></h2>
<p>앞의 예에서 치환 후의 문자열만 사용한다면 치환할 때마다 변수를 다시 선언하는 것은 비효율적이다. 러스트에서는 섀도잉(Shadowing)이라는 기능이 있어 같은 스코프 안에서 이전에 선언한 변수와 같은 이름의 새
변수를 선언할 수 있다. 같은 이름을 가진 변수를 선언하면 이전에 선언한 변수의 값이 숨겨지고(shadowed) 새로 선언된 변수의 값을 갖게 된다.</p>
<p>다음은 앞 예제에서 섀도잉을 이용해 변수 이름을 바꾸지 않고 값을 바꾸는 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let s = &quot;내 자신에 대한 자신감을 잃으면 온 세상이 나의 적이 된다.&quot;;
    let s = s.replace(&quot;잃으면&quot;, &quot;가지면&quot;);
    let s = s.replace(&quot;적이&quot;, &quot;편이&quot;);
    println!(&quot;{}&quot;, s);
}</code></pre></pre>
<p>프로그램을 실행해보자. 섀도잉으로 인해 같은 이름의 변수를 여러 번 사용했지만 문제없이 실행되는 것을 알 수 있다.</p>
<p>섀도잉을 이용하면 잠시 사용하기 위한 변수를 만드는 수고를 덜 수 있다. 그리고 가변 변수를 이용하는 부분을 줄일 수도 있다.</p>
<p>예를 들어 변수 <code>v</code>에 덧셈을 한 번 하기 위해 <code>v</code>를 가변 변수로 선언하는 것은 좋은 생각은 아니다. 이럴 때 섀도잉을 이용하면 불필요한 가변 변수를 쓰지 않고도 해결할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 섀도잉을 이용하지 않음 (1)
    {
        let mut v = 300;  // v를 가변 변수로 선언
        v = v + 5;
        println!(&quot;{}&quot;, v);
    }

    // 섀도잉을 이용 (2)
    {
        let v = 300;  // v는 불변 변수
        let v = v + 5;
        println!(&quot;{}&quot;, v);
    }
}</code></pre></pre>
<ol>
<li>변수 <code>v</code>를 가변 변수로 선언했다. 덧셈 한 번을 위해 가변 변수를 선언하면 나중에 실수로 <code>v</code>의 값을 변경하는 등 버그의 원인이 될 수 있다.</li>
<li>섀도잉을 이용하므로 불변 변수를 이용해도 문제가 없다. 섀도잉을 하면 섀도잉 전의 값은 이용할 수 없지만 변수는 여전히 불변이므로 안전하다.</li>
</ol>
<h2 id="문자열-분할"><a class="header" href="#문자열-분할">문자열 분할</a></h2>
<p>문자열을 자를 때는 특정 위치에서 자르거나 구분자로 사용할 문자로 자를 수 있다.</p>
<p>다음은 전화번호 031-943-2839에서 지역번호 031을 제외한 '943-2839'을 국번과 사번으로 나누는 예다. 슬라이스를 제외하고 3가지 메서드를 이용해 분할한다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 전화번호 지정
    let telno = &quot;943-2839&quot;;

    // 슬라이스로 분할 (1)
    println!(&quot;-- 슬라이스 --&quot;);
    println!(&quot;국번: {}&quot;, &amp;telno[..3]);
    println!(&quot;사번: {}&quot;, &amp;telno[4..]);

    // split_at으로 분할 (2)
    println!(&quot;--- split_at ---&quot;);
    let (telno1, telno2) = telno.split_at(3);
    let (telno2, telno3) = telno2.split_at(1);
    println!(&quot;국번: {}&quot;, telno1);
    println!(&quot;구분: {}&quot;, telno2);
    println!(&quot;사번: {}&quot;, telno3);

    // split_off로 분할 (3)
    println!(&quot;-- split_off --&quot;);
    let mut telno1 = String::from(telno);
    let mut telno2 = telno1.split_off(3);
    let telno3 = telno2.split_off(1);
    println!(&quot;국번: {}&quot;, telno1);
    println!(&quot;구분: {}&quot;, telno2);
    println!(&quot;사번: {}&quot;, telno3);

    // split으로 분할 (4)
    println!(&quot;-- split --&quot;);
    let telno_a: Vec&lt;&amp;str&gt; = telno.split('-').collect();
    println!(&quot;국번: {}&quot;, telno_a[0]);
    println!(&quot;사번: {}&quot;, telno_a[1]);
}</code></pre></pre>
<p>컴파일 후 실행해보면 국번과 사번이 나뉘어 출력되는 것을 확인할 수 있다.</p>
<ol>
<li>슬라이스를 이용한 분할이다. 직접 범위를 지정해 추출한다.</li>
<li><code>split_at</code> 메서드를 이용한다. 임의의 위치를 지정해 해당 위치를 기준으로 문자열을 분리해 튜플 <code>(&amp;str, &amp;str)</code> 타입을 반환한다.</li>
<li><code>split_off</code> 메서드를 이용한 방법이다. <code>split_off</code>를 이용하면 인수로 지정한 바이트 수를 남겨 그 값을 반환한다. 먼저 첫 변수 <code>telno1</code>에 <code>String::from</code>을 이용해 전화번호
문자열을 대입한다. 그리고 <code>telno1.split_off(3)</code>을 하면 처음 3바이트인 943가 <code>telno1</code>에 남고 나머지 (-2839) 부분은 <code>telno2</code>에 대입된다.
그리고 <code>telno2.split_off(1)</code>로 <code>telno2</code>에 하이픈(<code>-</code>)을 남기고 <code>telno3</code>에 나머지 부분인 2839가 대입된다.</li>
<li><code>split</code> 메서드를 이용하는 방법이다. <code>split</code> 메서드는 구분할 기준 문자를 지정하면 해당 문자를 기준으로 문자열이 분리된다. <code>split</code> 메서드는 <code>Vec&lt;&amp;str&gt;</code> 타입을 반환한다. 이 메서드는
구분자는 출력하지 않는다.</li>
</ol>
<h2 id="euc-kr로-인코딩된-파일-읽고-쓰기"><a class="header" href="#euc-kr로-인코딩된-파일-읽고-쓰기">EUC-KR로 인코딩된 파일 읽고 쓰기</a></h2>
<p>러스트는 UTF-8을 이용해 문자열을 처리하므로 EUC-KR 같이 UTF-8로 인코딩되지 않은 파일을 다루기 위해서는 변환 작업을 해야 한다. 지금은 대부분 UTF-8을 이용하지만, 예전 버전 윈도우에서는 별도로
지정하지 않는 이상 EUC-KR 인코딩으로 저장된다. 여기서는 EUC-KR 문서를 다루기 위해 <code>encoding_rs</code>라는 크레이트를 이용한다.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use encoding_rs;
use std::fs;
use std::fs::File;
use std::io::Write;

fn main() {
    // 저장할 파일 이름 지정
    let filename = &quot;test-euckr.txt&quot;;

    // EUC_KR로 저장 (1)
    save_euckr(filename, &quot;맛있게 먹으면 0칼로리&quot;);

    // EUC_KR 파일 읽어오기 (2)
    let s = load_euckr(filename);
    println!(&quot;{}&quot;, s);
}

fn save_euckr(filename: &amp;str, text: &amp;str) {
    // EUC_KR로 인코드 (3)
    let (enc, _, _) = encoding_rs::EUC_KR.encode(text);
    let buf = enc.into_owned();

    // 파일 생성 및 내용 쓰기 (4)
    let mut file = File::create(filename).expect(&quot;생성&quot;);
    file.write(&amp;buf[..]).expect(&quot;쓰기&quot;);
}

fn load_euckr(filename: &amp;str) -&gt; String {
    // 파일을 한 번에 읽어들임 (5)
    let buf = fs::read(filename).expect(&quot;읽기&quot;);

    // EUC_KR로 디코드 (6)
    let (dec, _, _) = encoding_rs::EUC_KR.decode(&amp;buf);
    dec.into_owned()
}</code></pre></pre>
<p>프로그램을 빌드한 뒤 실행해보면, 파일이 하나 생성되고 파일의 내용이 출력된다. 실행 전에는 없던 <code>test-euckr.txt</code> 파일이 생성된 것을 확인할 수 있다.</p>
<pre><code class="language-text">$ cargo run
   Compiling cfg-if v1.0.0
   Compiling encoding_rs v0.8.31                                                                                                                                                                                                  
   Compiling enc_save_load v0.1.0 (C:\Users\jerok\projects\rust\rust_programming_examples\src\ch03\enc_save_load)                                                                                                                 
    Finished dev [unoptimized + debuginfo] target(s) in 3.06s                                                                                                                                                                     
     Running `target\debug\enc_save_load.exe`
맛있게 먹으면 0칼로리
</code></pre>
<p>소스 코드의 (1)과 (2)는 지정한 파일 이름으로 저장하는 함수와 저장된 파일을 불러오는 함수를 호출하는 부분이다.</p>
<ol start="3">
<li>러스트이 문자열을 EUC-KR로 인코딩한다. <code>encoding_rs</code>는 다양한 언어로 인코딩을 할 수 있다. <code>encode</code> 메서드를 이용해 인코딩을 하면 <code>(Cow&lt;[u8]&gt; Encoding, bool)</code>
형태의 튜플을 반환한다. 이 중 <code>Cow&lt;[u8]&gt;</code>은 EUC-KR로 인코딩된 바이너리 배열 슬라이스다. <code>Cow</code>는 데이터 참조와 소유가 모두 가능한 객체다. <code>into_owned</code> 메서드를 호출해 소유권을
가져올 수 있다.</li>
<li>바이너리 배열을 파일로 저장한다. <code>File::create</code>로 파일을 생성하고 <code>file.write</code>를 이용해 데이터를 파일에 쓴다. <code>create</code>와 <code>write</code> 메서드에 <code>expect</code>를 지정해 작업이
실패하면 어느 부분에서 에러가 발생했는지 바로 알 수 있게 했다.</li>
<li><code>fs::read</code>를 이용해 파일에서 바이트 배열을 읽는다.</li>
<li>EUC-KR의 <code>decode</code> 메서드를 이용해 바이너리 배열을 UTF-8로 디코드한다. <code>decode</code>의 반환값은 <code>(Cow&lt;str&gt;, Encoding, bool)</code> 형태의 튜플이다. <code>Cow&lt;str&gt;</code>
에 <code>into_owned</code>메서드를 이용해 소유권을 획득하면 <code>String</code> 타입 문자열을 얻을 수 있다.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="rust_string.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="trait.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="rust_string.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="trait.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
