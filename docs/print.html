<!DOCTYPE HTML>
<html lang="kr" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fast⚡ and Robust🛡️</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="home.html">Home</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">토막글</li><li class="chapter-item expanded "><a href="rust.html"><strong aria-hidden="true">1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust_ownership.html"><strong aria-hidden="true">1.1.</strong> 소유권 시스템</a></li><li class="chapter-item expanded "><a href="rust_borrowing.html"><strong aria-hidden="true">1.2.</strong> 빌림과 참조</a></li><li class="chapter-item expanded "><a href="rust_string.html"><strong aria-hidden="true">1.3.</strong> 러스트의 문자열</a></li><li class="chapter-item expanded "><a href="rust_string_02.html"><strong aria-hidden="true">1.4.</strong> 러스트의 문자열 처리에 익숙해지기</a></li><li class="chapter-item expanded "><a href="trait.html"><strong aria-hidden="true">1.5.</strong> 공통 동작을 정의하는 트레잇</a></li><li class="spacer"></li><li class="spacer"></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fast⚡ and Robust🛡️</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jerok-kim/jerok-kim.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="프로젝트들"><a class="header" href="#프로젝트들">프로젝트들</a></h2>
<hr />
<h2 id="공부-정리글-모음"><a class="header" href="#공부-정리글-모음">공부 정리글 모음</a></h2>
<h3 id="자료구조와-알고리즘"><a class="header" href="#자료구조와-알고리즘">자료구조와 알고리즘</a></h3>
<ul>
<li><strong><a href="https://jerok-kim.github.io/data_structures_and_algorithms/">Data Structures and Algorithms</a></strong>.</li>
</ul>
<h3 id="c"><a class="header" href="#c">C</a></h3>
<ul>
<li><strong><a href="https://jerok-kim.github.io/do_it_c/">Do it C 입문</a></strong>. </li>
</ul>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<ul>
<li><strong><a href="https://jerok-kim.github.io/rust_in_action/">Rust in Action</a></strong>.</li>
<li><strong><a href="https://jerok-kim.github.io/rust_lang_book/">Rust Programming Language</a></strong>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-1"><a class="header" href="#rust-1">Rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>#패스트캠퍼스, #국비지원교육, #메가바이트스쿨, #MegabyteSchool, #개발자취업부트캠프, #내일배움카드</p>
<p><em>last edited 2023.01.26</em></p>
<h1 id="러스트의-소유권-시스템에-대해-쉬운-설명으로-알아보자"><a class="header" href="#러스트의-소유권-시스템에-대해-쉬운-설명으로-알아보자">러스트의 소유권 시스템에 대해 쉬운 설명으로 알아보자</a></h1>
<blockquote>
<p>▶ 만들면서 배우는 러스트 프로그래밍 -쿠지라 히코우즈쿠에- ◀ 을 참조하여 정리하였다.</p>
</blockquote>
<p>러스트에는 메모리 안전성을 확보하기 위한 '소유권(ownership)'이라는 시스템이 있다. 이는 다른 언어에서는 없는 개념으로 러스트를 배우는데 있어서 첫번째 난관이 된다.</p>
<h2 id="소유권-시스템이란-무엇인가"><a class="header" href="#소유권-시스템이란-무엇인가">소유권 시스템이란 무엇인가</a></h2>
<p>러스트는 안전성을 가지면서도 효율적인 고속 프로그래밍 언어다. 마찬가지로 효율적인 프로그래밍 언어인 C 언어는 메모리 관리가 어렵고, 메모리와 관련된 버그가 많이 발생한다. 안전성 향상에 큰 역할을 하는 것이 바로
이 소유권 시스템이다. 소유권 시스템은 러스트의 가장 중심이 된다고 해도 과언이 아니다.</p>
<h3 id="소유권-시스템을-간단히-표현하면"><a class="header" href="#소유권-시스템을-간단히-표현하면">소유권 시스템을 간단히 표현하면</a></h3>
<p>소유권 시스템은 간단히 말하면 <strong>확보한 메모리를 사용이 끝난 시점에 자동으로 파기하는 기능</strong>이다. 확보한 메모리를 이용할 수 있는 범위를 명확히 한정 지어 효율적으로 메모리를 관리한다.</p>
<p>이 구조를 러스트 코드 형태로 확인해보자. 러스트에서는 중괄호를 이용해 임의의 장소에 블록을 선언할 수 있다.</p>
<p>(스포일러 주의! 예시에서 <code>String</code>타입을 사용했다는 것을 유념하자.)</p>
<pre><code class="language-rust  noplayground">{
    // 여기서 String 메모리를 확보
    let s = String::from(&quot;hello&quot;);
    // ...
    // ... 여기서 변수 s를 이용한 처리를 수행
    // ...
}
// 블록을 벗어나면 변수 s의 메모리를 파기</code></pre>
<p>이 예시는 기본적인 소유권 시스템의 동작을 나타낸다. 블록 안에서 확보된 메모리는 블록을 벗어나는 순간 자동으로 파기된다. 이처럼 러스트는 메모리의 유효 범위가 정해져 있다.</p>
<p>메모리를 확보한 후에 그 메모리를 누군가 책임지고 파기해야 하는 부분도 명확하게 정해져 있다.</p>
<p>예를 들어 다음과 같은 코드에서는 변수 <code>s1</code>에서 메모리를 확보한다. 그리고 도중에 변수 <code>s2</code>로 확보된 메모리가 이동된다.</p>
<pre><code class="language-rust  noplayground">{
    // 여기서 메모리를 확보
    let s1 = String::from(&quot;hello&quot;);
    
    // 다른 변수에 값을 넘긴다
    let s2 = s1;
}
// 블록을 벗어나면 변수 s2의 메모리를 파기</code></pre>
<p>이 경우 변수 <code>s1</code>에서 확보한 메모리는 <code>s2</code>로 이동된다. 변수 <code>s1</code>과 <code>s2</code>의 메모리를 모두 파기하려고 하면 메모리 이중 해제가 발생한다. 그래서 변수 <code>s1</code>에서 <code>s2</code>로 값을 이동한 것을 러스트
컴파일러가 검출해 변수 <code>s2</code>이 메모리만을 파기하도록 한다.</p>
<p>다음 그림은 프로그램의 동작과 그에 따른 메모리 상태를 나타낸다. 변수 <code>s1</code>에서 변수 <code>s2</code>로 메모리가 이동하면 변수 <code>s1</code>은 더 이상 이용할 수 없다. 그리고 블록을 벗어나면 변수 <code>s2</code>의 메모리가
파기된다. 메모리 이중 해제는 심각한 메모리 에러가 발생한다. 러스트 컴파일러는 변수 <code>s1</code>에서 변수 <code>s2</code>로 값이 이동할 때 <code>s1</code>을 이용할 수 없게 관리하므로 이중 해제는 발생하지 않는다.</p>
<p><img src="./images/ownership_01.png" alt="프로그램 동작과 메모리 상태" /></p>
<p>이 기본적인 구조를 러스트에서는 '소유권'이라고 한다. 그리고 메모리의 유효성을 검증하는 컴파일러의 이 기능을 Borrow checker(빌림 확인)라고 한다.</p>
<h3 id="소유권-시스템의-장점"><a class="header" href="#소유권-시스템의-장점">소유권 시스템의 장점</a></h3>
<p>러스트에는 이 소유권 시스템이 있기 때문에 수동으로 메모리 확보와 해제를 하는 C/C++ 언어에서 종종 발생하는 메모리 관련 오류(이중 해제, 미해제)는 발생하지 않는다. 해제된 메모리를 가리키는 포인터를 '댕글링
포인터(Dangling pointer)'라고 한다. 이 댕글링 포인터에 혹시 접근이 되면 보안 취약점으로 이어지는 경우가 있다. 러스트에서는 기본적으로 댕글링 포인터에 접근할 수 없다. 소유권 시스템으로 인해
메모리가 원인이 되는 문제는 원천적으로 방지되며 메모리 안전성이 확보된다. 이것은 큰 장점이다.</p>
<p>GC(가비지 컬렉터 - Garbage collector)가 있는 언어라면 이런 메모리 관련 문제로 고민하지 않아도 된다. 하지만 GC는 메모리 관리 때문에 실행 속도나 메모리 효율을 희생해야 한다는 단점이 있다.
러스트는 GC를 이용하지 않고 소유권 시스템을 통해 메모리 관리를 하므로 안전하며 효율적으로 고속 프로그램을 만들 수 있다.</p>
<h3 id="소유권-시스템의-단점"><a class="header" href="#소유권-시스템의-단점">소유권 시스템의 단점</a></h3>
<p>물론 소유권 시스템에 장점만 있지는 않다.</p>
<p>프로그래머가 소유권 시스템에 대해 제대로 이해해야 한다. 물론 새로운 프로그래밍 언어를 배울 때는 그 언어의 특징을 이해하는 것이 당연하지만 소유권 시스템은 다른 언어에서는 일반적인 개념은 아니므로 이해에 어려움이
따를 수 있다. 그리고 이는 러스트가 어렵다는 인상을 주는 데도 한몫한다.</p>
<blockquote>
<h4 id="소유권-시스템은-러스트-독자적인-것인가"><a class="header" href="#소유권-시스템은-러스트-독자적인-것인가">소유권 시스템은 러스트 독자적인 것인가?</a></h4>
<p>러스트의 소유권 시스템은 독자적으로 만든 것이 아니라 C++ 언어의 스마트 포인터(Smart pointer)가 그 기원이 된다. C++언어의 새로운 규격인 C++ 11(ISO/IEC 14882:2011)에는
표준으로 스마트 포인터를 이용할 수 있으며 소유권과 그 이동에 대한 기능이 포함돼 있다.</p>
</blockquote>
<h2 id="메모리-관리를-소유권으로-생각하는-것"><a class="header" href="#메모리-관리를-소유권으로-생각하는-것">메모리 관리를 '소유권'으로 생각하는 것</a></h2>
<p>'소유권'이라는 말의 의미는 무엇일까. 사전적인 정의를 보면 '물건을 전면적, 일반적으로 지배하는 권리. 물건이 가지는 사용 가치나 교환 가치의 전부를 지배할 수 있는 권리'라고 설명돼 있다. 그리고 '소유자'는 그
소유권을 가진 사람을 말한다.</p>
<p>예를 들어 어떤 집에 대한 소유권을 생각해보자. 집의 소유권을 가진 사람인 소유자는 그 집에서 살 수 있다. 가구 배치도 원하는 대로 할 수 있으며 집 안의 시설을 이용해 쾌적한 생활도 할 수 있다. 하지만 그 집을
누군가에게 팔면 그 집에 대한 아무런 권리도 없으므로 그 집에서 더 이상 살 수 없다.</p>
<p>러스트의 소유권 시스템도 이와 마찬가지다. 변수를 대입하거나 함수를 호출해 소유권을 가질 수 있지만 그 소유권이 한번 이동하면 원래의 변수는 다시 이용할 수 없다.</p>
<p>집은 소유하고 있는 중에 자기가 사는 것이 아니라 다른 누군가에게 세를 줄 수 있다. 이 경우 집의 소유권은 소유자에게 있지만 그 집에 살 수 있는 권리는 세입자에게 있다. 러스트에서도 이렇게 일시적으로 권리를
부여해줄 수 있다. 메모리 관리에 '소유권'이라는 말을 이용하는 것은 꽤 잘 어울린다.</p>
<h2 id="소유권의-3대-기본-원칙"><a class="header" href="#소유권의-3대-기본-원칙">소유권의 3대 기본 원칙</a></h2>
<p>러스트의 소유권 시스템에는 기본적인 세 가지 원칙이 있다.</p>
<ol>
<li><strong>값에는 '소유권'이 있으며 변수는 값의 '소유자'가 된다.</strong></li>
<li><strong>소유권은 이동할 수 있지만 '소유자'는 1개(1개의 변수)뿐이다.</strong></li>
<li><strong>'소유자'가 유효한 범위(Scope)를 벗어나면 값은 파기된다.</strong></li>
</ol>
<p>이 원칙을 조금 더 자세히 살펴보자.</p>
<p>원칙 1은 '소유권'과 '소유자'를 규정하는 것이다. 러스트에서 다루는 '값'에는 소유권이 있으며 그 소유권을 가지는 '소유자'가 있다는 것이다.</p>
<p>원칙 2는 값의 소유권은 한 변수에서 다른 변수로 '이동(move)'할 수 있다는 것이다. 소유권이 이동한 뒤에는 그 변수를 이용할 수 없다. 소유권의 이동은 변수에 값을 대입하거나 함수를 호출했을 때 발생한다.</p>
<p>예를 들어 물과 물컵을 가지고 생각해보자. 물컵이 '변수'이며 물 그 자체는 '소유권'이라고 가정한다.</p>
<p>물컵 a에 따른 물을 물컵 b에 옮겨 따랐다. 이때 물컵 a는 비어 있으므로 마실 수 없는 상태다. 마찬가지로 변수 a에 있는 소유권을 변수 b로 옮기면 변수 a는 값이 없는 상태이므로 사용할 수 없는 것이다.</p>
<p><img src="./images/ownership_02.png" alt="(원칙 1)과 (원칙 2) 값에는 소유권이 있으며 소유자 간에 이동한다." /></p>
<p>원칙 3은 소유권의 파기에 관한 규칙이다. 변수에는 이용 가능한 범위(Scope)가 있다. 변수가 유효한 범위를 벗어나면 자동적으로 변수는 파기된다. 그리고 변수를 파기할 때 변수가 값의 소유권을 가지고 있다면 값
역시 파기된다. 러스트에 소유권 시스템이 있는 것은 이렇게 명확한 메모리 파기 규칙을 위해서다.</p>
<p><img src="./images/ownership_03.png" alt="(원칙 3) 소유자가 유효 범위 밖으로 나갔을 때 값을 파기한다." /></p>
<h4 id="소유권-시스템-체험하기"><a class="header" href="#소유권-시스템-체험하기">소유권 시스템 체험하기</a></h4>
<p>소유권 시스템을 프로그램에서 직접 확인해보자. 다음은 소유권 시스템의 간단한 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let g1 = String::from(&quot;온화한 마음은 몸에 좋다.&quot;);  // (1)
    let g2 = g1;  // 소유권을 g2로 이동 (2)
    println!(&quot;{}&quot;, g2);  // (3)
}</code></pre></pre>
<p>이 소스 코드는 문제가 없다. (1)에서 <code>String::from</code> 메서드를 이용해 <code>String</code> 객체를 만들고 변수를 <code>g1</code>에 대입한다. 이때 <code>String</code> 객체의 소유자는 <code>g1</code>이다. <code>g1</code>
이 <code>String</code> 객체의 소유권을 가지고 있는 것이다.</p>
<p>그리고 (2)에서 변수 <code>g2</code>에 <code>g1</code>을 대입한다. 이를 통해 객체의 소유권은 <code>g1</code>에서 <code>g2</code>로 '이동(move)'한다.</p>
<p>(3)에서는 <code>g2</code>의 내용을 화면에 표시한다. <code>String</code> 객체의 값은 변수 <code>g1</code>에서 <code>g2</code>로 이동됐으므로 <code>g2</code>의 내용을 출력할 수 있다.</p>
<p>물컵의 예로 생각해보자. (1)에서는 물을 <code>g1</code>이라는 컵에 부었다. (2)에서는 <code>g2</code>라는 컵에 <code>g1</code>컵에 들어있던 물을 부었다. <code>g1</code>잔은 비어있으므로 마실 수 없다.</p>
<p>그렇다면 비어있는 <code>g1</code>을 이용하고자 하면 어떻게 될까. 위의 소스 코드를 변경해서 확인해보자.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let g1 = String::from(&quot;온화한 마음은 몸에 좋다.&quot;);  // (1)
    let g2 = g1;  // 소유권을 g2로 이동 (2)
    println!(&quot;{}&quot;, g1);  // 비어있는 g1을 이용할 수 있을까?
}</code></pre></pre>
<p>이 소스 코드를 컴파일하려 하면 다음과 같이 에러가 발생한다.</p>
<pre><code class="language-text">$ rustc owner_simple_err.rs
warning: unused variable: `g2`
 --&gt; owner_simple_err.rs:3:9
  |
3 |     let g2 = g1;  // 소유권을 g2로 이동
  |         ^^ help: if this is intentional, prefix it with an underscore: `_g2`
  |
  = note: `#[warn(unused_variables)]` on by default

error[E0382]: borrow of moved value: `g1`
 --&gt; owner_simple_err.rs:4:20
  |
2 |     let g1 = String::from(&quot;온화한 마음은 몸에 좋다.&quot;);
  |         -- move occurs because `g1` has type `String`, which does not implement the `Copy` trait       
3 |     let g2 = g1;  // 소유권을 g2로 이동
  |              -- value moved here
4 |     println!(&quot;{}&quot;, g1);  // 비어있는 g1을 이용할 수 있을까?
  |                    ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0382`.
</code></pre>
<p>'error[E0382]: borrow of moved value: <code>g1</code> (이동된 값 g1을 빌리려 했음)'이라는 에러가 발생한다. 그리고 <code>g1</code>에 'value borrowed here after move(이동
후에 여기서 값을 빌림)'라는 에러 메시지가 표시된다. 빌림은 소유권 시스템에서 이용하는 개념 중 하나로 소유자에게 값을 빌리거나 돌려줄 수 있다. 이에 대해서는 나중에 알아보자. 여기서는 물컵의 예에서 <code>g1</code>은
이미 빈 컵이므로 물을 마실 수 없다는 의미로 이해하자.</p>
<h3 id="소유자가-유효-범위에서-벗어나면-파기"><a class="header" href="#소유자가-유효-범위에서-벗어나면-파기">소유자가 유효 범위에서 벗어나면 파기</a></h3>
<p>3번째 원칙인 범위를 벗어나는 경우 값을 파기한다는 점에 대해서도 생각해보자. 러스트에서는 중괄호 <code>{ ... }</code>로 블록(범위)을 표현할 수 있다. 즉 중괄호 안에 선언한 변수에 대입한 값은 중괄호를 벗어나면
파기된다. 러스트는 범위를 벗어나면 <strong>범위 안에서 이용한 변수에 대해 자동으로 drop 함수를 호출</strong>한다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 블록
    {
        let s1 = String::from(&quot;재능은 한계가 있지만 노력엔 한계가 없다&quot;);
        println!(&quot;{}&quot;, s1);
    }
    // 블록을 벗어나면 s1은 파기된다.
}</code></pre></pre>
<p>여기서는 블록 안에서 <code>String</code>객체를 생성하고 변수 <code>s1</code>에 대입한다. 이때 변수 <code>s1</code>에 객체의 소유권이 있다. 이 블록을 벗어날 때, 즉 소유자 <code>s1</code>의 유효 범위에서 벗어날 때 <code>s1</code>이 소유권을
가지고 있던 <code>String</code>객체가 파기된다.</p>
<p>다음 프로그램도 확인해보자. 블록 1 안에서 또 다른 블록 2를 설정했다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 블록 1
    {
        let s1 = String::from(&quot;인생에 뜻을 세우는 데 있어 늦은 때라곤 없다.&quot;);
        let s3 = String::from(&quot;한걸음 한걸음씩&quot;);
        
        // 블록 2
        {
            let s2 = s1;
            println!(&quot;{}&quot;, s2);
        }
        // s2의 값은 여기서 파기된다.
        
        println!(&quot;{}&quot;, s3);
    }
    // s3의 값은 여기서 파기된다.
}</code></pre></pre>
<p>블록 1 안에서 <code>s1</code>과 <code>s3</code>에 <code>String</code> 객체를 만들어 대입했다. 블록 2 안에서 <code>s2</code>에 <code>s1</code>을 대입했다. 여기서 <code>s1</code>의 값 소유권이 <code>s2</code>로 이동한다. 그리고 이곳은 다른 블록의 안쪽이므로
이 블록을 벗어나면 변수 <code>s2</code>는 사용할 수 없다. 그와 동시에 <code>s2</code>가 소유권을 가지고 있는 값 '인생에 뜻을 세우는 데 있어 늦은 때라곤 없다.'라는 문자열도 파기된다. 마지막으로 블록 1이 종료될
때 <code>s3</code>의 값도 파기된다.</p>
<h2 id="소유권-시스템을-적용받지-않는-타입"><a class="header" href="#소유권-시스템을-적용받지-않는-타입">소유권 시스템을 적용받지 않는 타입</a></h2>
<p>러스트의 모든 값이 소유권 시스템의 대상이 되는 것은 아니다. 정수, 부동 소수점 등의 숫자 타입, Boolean 타입 등은 소유권 시스템이 동작하지 않는다. 이 타입은 대입(bind-속박)이나 함수 호출이 될 때
소유권이 이동(move)하는 것이 아니라 자동으로 복사(copy)된다. 따라서 소유권 이동은 일어나지 않는다. 이런 기본 타입은 컴파일할 때 데이터의 크기가 명확하게 결정되어 있어 해당 데이터가 스택 영역에
확보된다.</p>
<h3 id="힙-영역과-스택-영역"><a class="header" href="#힙-영역과-스택-영역">힙 영역과 스택 영역</a></h3>
<p>'힙(heap) 영역'과 '스택(stack) 영역'은 무엇일까. 메모리 관리는 OS의 일이다. OS는 응용 프로그램의 요청에 따라 메모리를 할당하거나 불필요해진 메모리를 회수한다. OS는 메모리를 할당할 때 크게 두
가지 방법으로 메모리를 관리한다. 이것이 힙과 스택이다.</p>
<p>'힙 영역'에 저장된 메모리는 임의의 순서로 메모리를 확보하거나 해제할 수 있다. 원할 때 필요한 만큼 메모리를 확보할 수 있다. 반면 '스택 영역'에 저장된 메모리는 순차적(마지막에 있는 메모리부터)으로만 메모리를
확보하고 해제할 수 있다.</p>
<p>따라서 메모리 크기가 이미 정해진 데이터는 스택 영역에 저장할 수 있지만 크기가 변하는 가변 데이터는 힙 영역에 저장해야 한다. 그래서 문자열(<code>String</code> 타입)이나 구조체 같이 크기가 변하는 데이터는 힙 영역에
저장된다.</p>
<p>반면 숫자 데이터 등의 기본 타입 데이터는 스택 영역에 저장되므로 데이터 복제가 빠르고 쉽다. 그래서 처음부터 소유권 관리를 하지 않고 값을 복사하는 것이다.</p>
<h3 id="기본-타입에서-소유권이-이동하지-않는-것을-확인"><a class="header" href="#기본-타입에서-소유권이-이동하지-않는-것을-확인">기본 타입에서 소유권이 이동하지 않는 것을 확인</a></h3>
<p>기본 타입 데이터에서 소유권이 정말 이동하지 않는지 프로그램을 만들어 확인해보자. 다음은 변수 <code>g2</code>에 <code>g1</code>의 값을 대입한 뒤 <code>g1</code>을 계속해서 이용하는 것을 보여주는 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let g1 = 30;
    let g2 = g1;  // 값이 자동으로 복사됨 (1)
    println!(&quot;{}&quot;, g1);  // ok
    println!(&quot;{}&quot;, g2);  // ok
}</code></pre></pre>
<p>컴파일 후 프로그램을 실행해보면 <code>g1</code>의 값과 <code>g2</code>의 값이 모두 출력되는 것을 확인할 수 있다.</p>
<p>컴파일 에러도 발생하지 않고, <code>g1</code>과 <code>g2</code>의 값을 모두 출력했다. 위 소스 코드를 소유권 에러가 발생했던 소스 코드와 비교해보자.</p>
<p>에러가 발생한 소스 코드에서는 <code>String</code>타입 데이터를 이용했고 이 소스 코드에서는 <code>i32</code>타입 데이터를 이용했다.</p>
<p>(1) 부분에서 <code>g1</code>의 값을 <code>g2</code>에 대입한다. 이때 기본 타입 데이터는 스택 영역에 저장되므로 직접 복사된다. 반면 기본 타입 외 데이터는 힙 영역에 보관되므로 소유권 시스템의 관리를 받게 된다. 따라서
복사가 아니라 이동으로 처리된다.</p>
<p>표를 통해 이 내용을 다시 한번 확인해보자.</p>
<div class="table-wrapper"><table><thead><tr><th>데이터 타입</th><th><code>let</code> 문으로 대입했을 때의 동작</th></tr></thead><tbody>
<tr><td>기본 타입(Primitive type - 원시 타입)</td><td>복사(copy)</td></tr>
<tr><td>기본형 외의 타입</td><td>이동(move)</td></tr>
</tbody></table>
</div>
<p>단, <strong>기본형 이외의 데이터 타입에서도 <code>Copy</code> 트레잇(<code>trait</code>)을 구현한 데이터 타입이라면 데이터를 복사 할 수 있다</strong>. 기본 타입 데이터는 모두 <code>Copy</code>트레잇이 구현되어 있다. 트레잇이란 다른
데이터형에 대해 공통 동작을 정의하는 것이다.</p>
<h3 id="참조-카운터로-값을-관리하는-rc와-arc"><a class="header" href="#참조-카운터로-값을-관리하는-rc와-arc">참조 카운터로 값을 관리하는 Rc<T>와 Arc<T></a></h3>
<p>기본 타입 값 이외에도 소유권 시스템에 적용되지 않는 값이 있다. 바로 <code>Rc&lt;T&gt;</code>와 <code>Arc&lt;T&gt;</code> 타입이다.</p>
<p>이 데이터 타입을 이용하면 참조 카운터를 사용해 메모리 관리를 할 수 있다. 표현 데이터에 따라서는 소유권 시스템보다 참조 카운터를 사용하는 게 메모리 관리에 유리할 수 있는데 그 경우 이 2가지 타입을 이용한다.</p>
<h4 id="복제할-때의-소유권"><a class="header" href="#복제할-때의-소유권">복제할 때의 소유권</a></h4>
<p>소유권이 이동하는 타입(문자열과 구조체)이라도 데이터를 복제(<code>clone</code>)해서 소유권 이동을 피할 수 있다. 다음은 <code>String</code>타입을 복제하는 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let g1 = String::from(&quot;온화한 마음은 몸에 좋다.&quot;);
    let g2 = g1.clone();  // 복제하면 소유권은 이동하지 않는다
    println!(&quot;{}&quot;, g1);  // ok
    println!(&quot;{}&quot;, g2);  // ok
}</code></pre></pre>
<p><code>g2</code>에 값을 대압하는 부분을 보면 <code>.clone()</code>이라는 메서드가 추가되어 있다. <code>String</code> 타입의 <code>clone</code> 메서드는 값을 복제하는 메서드다. 단순히 대입을 하면 소유권이 이동하지만 복제를 하면
소유권은 이동하지 않는다. 따라서 <code>g1</code>과 <code>g2</code>를 모두 이용할 수 있다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>#패스트캠퍼스, #국비지원교육, #메가바이트스쿨, #MegabyteSchool, #개발자취업부트캠프, #내일배움카드</p>
<p><em>last edited 2023.01.26</em></p>
<h1 id="빌림과-참조에-대해-쉬운-설명으로-알아보자"><a class="header" href="#빌림과-참조에-대해-쉬운-설명으로-알아보자">빌림과 참조에 대해 쉬운 설명으로 알아보자</a></h1>
<blockquote>
<p>▶ 만들면서 배우는 러스트 프로그래밍 -쿠지라 히코우즈쿠에- ◀ 을 참조하여 정리하였다.</p>
</blockquote>
<p>소유권은 함수를 호출해도 이동한다. 하지만 함수를 호출할 때마다 소유권이 이동하면 프로그래밍이 어려워진다. 그래서 일시적으로 소유권을 빌리는 '빌림'에 대해 알아보자. 빌림 외에도 함수와 소유권의 관계, 참조에
대해서도 알아본다.</p>
<h2 id="빌림이란"><a class="header" href="#빌림이란">'빌림'이란</a></h2>
<p>'빌림'은 빌려쓴다는 뜻이다. 실생활에서도 자기 것이 아닌 물건을 원 주인의 양해를 받고 가져와 쓰는 것을 빌린다고 한다.</p>
<p>러스트에서 말하는 빌림(borrow/borrowing)도 의미는 같지만 여기서는 물건이 아니라 값의 소유권이다. 그리고 빌리는 것이므로 소유권을 완전히 받는 것이 아니라 일시적으로 가져오고 사용이 끝나면 반납한다.</p>
<h2 id="함수-호출로-이동하는-소유권"><a class="header" href="#함수-호출로-이동하는-소유권">함수 호출로 이동하는 소유권</a></h2>
<p>소유권은 값 대입 외 함수 호출로도 이동한다. 함수를 호출할 때 인수로 값을 지정하면 그 값의 소유권은 호출한 함수의 인수로 이동한다.</p>
<p>함수 호출에 따른 소유권 이동에 대해 자세히 살펴보자.</p>
<pre><code class="language-rust  noplayground">fn main() {
    let g1 = String::from(&quot;실수할 줄 아는 사람이 아름답다.&quot;);
    show_message(g1);  // 소유권이 이동한다
    println!(&quot;{}&quot;, g1);  // g1은 사용할 수 없다.
}

fn show_message(message: String) {
    println!(&quot;{}&quot;, message);
}</code></pre>
<p>이 프로그램을 컴파일하면 다음과 같이 에러가 발생한다.</p>
<pre><code class="language-text">$ rustc owner_func_err.rs
error[E0382]: borrow of moved value: `g1`
 --&gt; owner_func_err.rs:4:20
  |
2 |     let g1 = String::from(&quot;실수할 줄 아는 사람이 아름답다&quot;);
  |         -- move occurs because `g1` has type `String`, which does not implement the `Copy` trait       
3 |     show_message(g1);  // 소유권이 이동한다
  |                  -- value moved here
4 |     println!(&quot;{}&quot;, g1);  // g1은 사용할 수 없다
  |                    ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
</code></pre>
<p>에러 메시지를 확인해보자. 직접적인 에러는 'error[E0382]: borrow of moved value: <code>g1</code>(이동된 값 g1을 빌림)'이다.</p>
<p>여기서 주목할 점은 어디에서 <code>g1</code>의 값이 이동했는지다. 프로그램의 3번째 줄에서 호출한 함수 <code>show_message</code>의 인수 <code>g1</code>부분에 'value moved here(여기에서 값이 이동됨)'이라는 힌트가
표시된다.</p>
<p>즉 함수 호출로 소유권 이동이 발생했으므로 4번째 줄의 <code>println!</code>에서 <code>g1</code>의 값을 사용할 수 없게 된 것이다.</p>
<h3 id="소유권-돌려주기"><a class="header" href="#소유권-돌려주기">소유권 돌려주기</a></h3>
<p>앞의 예제에서는 변수 <code>g1</code>의 소유권이 이동했으므로 에러가 발생했다. 이번에는 <code>g1</code>을 이용하면 함수를 호출한 곳에 소유권을 돌려주도록 해보자.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let mut g1 = String::from(&quot;실수할 줄 아는 사람이 아름답다.&quot;);
    g1 = show_message(g1);  // (1)
    println!(&quot;{}&quot;, g1);  // ok (2)
}

// String을 받아 String을 반환하는 함수
fn show_message(message: String) -&gt; String {
    println!(&quot;{}&quot;, message);
    return message;
}</code></pre></pre>
<p>컴파일 후 실행해보면 '실수할 줄 아는 사람이 아름답다.'라는 문장이 2번 출력된다.</p>
<p>소스 코드를 살펴보자. (1)에서는 변수 <code>g1</code>의 값을 인수로 지정해 함수를 호출한다. 이를 통해 <code>g1</code>값의 소유권은 함수로 넘어간다. 하지만 함수의 반환 값을 통해 소유권을 다시 돌려받는다. 그래서 (2)
에서도 <code>g1</code>을 이용할 수 있다.</p>
<p>물컵의 예로 생각하면 <code>g1</code>컴에 따라둔 물을 <code>show_message</code>함수의 인수 <code>message</code>라는 컵으로 옮긴 후 다시 <code>g1</code>컵으로 옮긴 상태다.</p>
<p>여기서 변수 <code>g1</code>을 선언할 때 <code>mut</code>을 붙여 가변 변수로 선언을 했다. 동일한 값인데 <code>mut</code>을 선언한 이유는 내부적으로 대입 동작이 발생하기 때문이다. 대입은 초기화와는 다른 동작이므로 값이 변하는 것으로
간주되기 때문이다.</p>
<p>(3)의 함수 <code>show_message</code>가 이전 예제와 다른 점은 인수 <code>message</code>를 그대로 반환 값으로 한 것이다. 이를 통해 함수를 호출했을 때 값 소유권을 함수의 변수 <code>message</code>로 이동한 뒤 실행이
종료되면 다시 함수를 호출한 곳으로 돌려줄 수 있다.</p>
<h3 id="참조와-빌림---함수-호출을-했을-때-소유권을-이동하지-않는-방법"><a class="header" href="#참조와-빌림---함수-호출을-했을-때-소유권을-이동하지-않는-방법">참조와 빌림 - 함수 호출을 했을 때 소유권을 이동하지 않는 방법</a></h3>
<p>함수 호출만으로 값의 소유권이 이동하는 것은 불편할 때도 있다. 그래서 러스트에는 소유권을 일시적으로 빌려주는 '빌림(borrow)'이라는 시스템을 마련해두고 있다.</p>
<p>값을 빌리기 위해서는 참조자를 나타내는 <code>&amp;</code>을 붙인다. 바꿔 말하면 <strong>함수의 인수를 '참조자'로 만드는 것을 '빌림'이라고 한다</strong>.</p>
<p>앞에서 다룬 예제를 빌림을 이용하는 형태로 변경해보자.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let g1 = String::from(&quot;실수할 줄 아는 사람이 아름답다.&quot;);
    show_message(&amp;g1);  // 참조 값을 전달 (1)
    println!(&quot;{}&quot;, g1);  // 소유권은 이동하지 않음 (2)
}

fn show_message(message: &amp;String) {  // (3)
    println!(&quot;{}&quot;, message);
}</code></pre></pre>
<p>컴파일 후 실행해보면 앞서와 마찬가지로 <code>show_message</code>에서 한 번, <code>println!</code>에서 한 번씩 메시지가 출력되어 총 2개의 메시지가 출력된다.</p>
<p>가장 앞 부분에서 설명한 에러가 발생하는 소스 코드와 비교해보면 차이점은 단 2글자뿐이다. (1)에서 함수를 호출할 때 참조자라는 것을 명시하기 위해 <code>&amp;</code>를 붙인 것, 그리고 (3)에서 함수의 인자로 참조자를
전달한다는 것을 명시하기 위해 역시 <code>&amp;</code>을 붙인 것이 전부다. 이를 통해 (2)에서 변수 <code>g1</code>의 값을 이용할 수 있다.</p>
<p>이처럼 참조자를 전달하도록 변경하면 소유권 문제를 해결할 수 있다. <strong>값을 참조해서 사용한다는 것은 값의 소유권을 일시적으로 빌리는 '빌림'이기 때문이다</strong>.</p>
<blockquote>
<h4 id="string은-str과-다른가"><a class="header" href="#string은-str과-다른가">&amp;String은 &amp;str과 다른가</a></h4>
<p>앞의 프로그램에서는 <code>String</code> 타입의 참조 타입인 <code>&amp;String</code>을 썼다. 하지만 문자열 참조 타입으로 <code>&amp;str</code>을 이용할 수도 있다. 러스트의 많은 함수는 문자열 참조 타입으로 <code>&amp;str</code>을
이용한다. <code>&amp;String</code>과 <code>&amp;str</code>은 대부분의 경우 동일하게 사용할 수 있다. 하지만 엄밀히 말하면 <code>&amp;str</code>은 슬라이스다. 슬라이스는 배열과 같은 요소의 일부를 참조하기 위한 타입이다. 자세한 내용은
문자열에 대해 알아볼때 다뤄보자.</p>
</blockquote>
<h2 id="참조자를-반환하는-함수"><a class="header" href="#참조자를-반환하는-함수">참조자를 반환하는 함수</a></h2>
<p>함수에서 참조자를 반환해야 하는 경우도 있다. 예를 들어 함수 안에서 어떠한 데이터를 만들고, 값이 아니라 그 참조자를 반환해야 하는 경우다. 그런데 러스트에서는 값에 수명(Lifetime)이 있다.</p>
<p>다음 소스 코드는 함수 <code>gen_message</code>로 메시지를 만든 뒤 그 참조자를 반환하려는 의도로 만들어진 것이다. 하지만 에러가 발생한다. 어떤 부분이 잘못되었는지 살펴보자.</p>
<pre><code class="language-rust  noplayground">// 메시지를 생성한 뒤 그 참조자를 반환하는 함수
fn gen_message() -&gt; &amp;str {
    let msg = String::from(&quot;실수할 줄 아는 사람이 아름답다.&quot;);
    return &amp;msg;
}

fn main() {
    let m = gen_message();
    println!(&quot;{}&quot;, m);
}</code></pre>
<pre><code class="language-text">$ rustc owner_lifetime_err.rs 
error[E0106]: missing lifetime specifier
 --&gt; owner_lifetime_err.rs:2:21
  |
2 | fn gen_message() -&gt; &amp;str {
  |                     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
2 | fn gen_message() -&gt; &amp;'static str {
  |                      +++++++

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
</code></pre>
<p>에러 메시지를 확인해보자. 'error[E0106]: missing lifetime specifier(수명 지시자가 없음)'이라고 표시된다. 도움말(help)을 보면 'this function's return
type contains a borrowed value, but there is no value for it to be borrowed from(이 함수가 반환하는 값은 빌린 값을 포함하고 있으나 빌림 값이 존재하지
않음)'이라고 표시된다.</p>
<p>즉, 수명을 지정하지 않았기 때문에 에러가 발생한 것이다.</p>
<p>앞에서 '소유자'가 유효한 범위(Scope)를 벗어나면 값은 파기된다'는 소유권 시스템의 기본 원칙을 바탕으로 생각해보자. 함수 <code>gen_message</code>는 하나의 범위다. 변수 <code>msg</code>는 <strong>이 범위 안에서만
유효하며 범위를 벗어나는 순간 <code>msg</code>값은 파기되는 것이다</strong>. 따라서 <code>msg</code>의 값에 대한 참조를 반환하더라도 <code>msg</code>값은 파기되므로 값이 사라지기 때문에 에러가 발생한다.</p>
<p>그렇다면 이 소스 코드를 어떻게 고쳐야 할까? <strong>참조가 안 된다면 실제값을 이용하면 된다</strong>. 즉 참조가 아닌 <code>String</code>객체의 실제값을 반환하도록 수정한다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">// 메시지 생성 함수
fn gen_message() -&gt; String {
    let msg = String::from(&quot;실수할 줄 아는 사람이 아름답다.&quot;);
    return msg;  // 소유권이 함수의 반환 값으로 이동 (1)
}

fn main() {
    let m = gen_message();  // 소유권은 m으로 이동 (2)
    println!(&quot;{}&quot;, m);  // ok
}</code></pre></pre>
<p>(1)부분에서 변수 <code>msg</code>값의 소유권은 함수의 반환 값으로 이동한다. 즉, (2)부분의 변수 <code>m</code>이 <code>msg</code>값의 소유권을 가지게 된다. 따라서 <code>println!</code> 매크로로 <code>m</code>의 값을 출력할 수 있다.</p>
<h2 id="가변-참조자를-인수로-사용하기"><a class="header" href="#가변-참조자를-인수로-사용하기">가변 참조자를 인수로 사용하기</a></h2>
<p>함수 호출에 참조자를 사용할 때 함수 안에서 인수의 값을 변경해야 하는 경우도 있다. 이때는 참조자가 가변이라는 것을 명시하면 함수 안에서 인수의 값을 변경할 수 있다.</p>
<p>다음은 인수에 지정한 <code>String</code> 타입 값을 함수 안에서 변경하는 프로그램이다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">// 인수의 문자열을 변경하는 함수 (1)
fn add_quote(msg: &amp;mut String) {
    msg.insert(0, '&quot;');
    msg.push('&quot;');
}

fn main() {
    let mut msg = String::from(&quot;건강한 신체에 건강한 정신이 깃든다.&quot;);
    println!(&quot;{}&quot;, msg);  // (2)
    add_quote(&amp;mut msg);  // (3)
    println!(&quot;{}&quot;, msg);  // (4)
}</code></pre></pre>
<p>컴파일 후 실행해보면 문자열의 앞뒤에 큰따옴표가 추가된 것을 확인할 수 있다.</p>
<p>함수의 인수로 지정한 값의 참조자를 변경하려면 (1)의 함수 정의에서 인수를 <code>&amp;mut</code> 타입 형태로 지정한다. 이렇게 하면 그 타입이 가변 참조자가 된다. 그리고 (3)에서와 같이 함수를 호출할 때 <code>&amp;mut</code>을
지정해 함수를 호출한다.</p>
<p><code>main</code>함수를 보면 <code>String</code>타입 값을 만들고 가변 변수 <code>msg</code>에 대입한다. 그리고 (2)에서 내용을 출력한다. (3)에서는 <code>add_quote</code>함수를 호출한다. 호출할 때 인수에 <code>&amp;mut</code>을 추가해
가변 참조자라는 것을 명시한다. <code>add_quote</code>함수는 <code>msg</code>의 앞과 뒤에 큰따옴표를 추가한다. 그리고 (4)에서 큰따옴표가 추가된 문자열을 출력한다.</p>
<p>여기서 주의할 것은 <code>add_quote</code>함수를 호출할 때 값 그 자체가 아니라 <code>mut</code>에 <code>&amp;</code>를 붙여 가변 참조자를 지정한다는 점이다. 참조자이므로 값을 빌리기만 하므로 (4)에서 <code>msg</code>를 이용할 수 있다.</p>
<h3 id="함수를-호출해서-인수를-변경하는-방법"><a class="header" href="#함수를-호출해서-인수를-변경하는-방법">함수를 호출해서 인수를 변경하는 방법</a></h3>
<p>함수의 인수로 지정한 변수를 변경하는 방법을 다시 한번 확인하자. 문법은 다음과 같다.</p>
<pre><code class="language-rust  noplayground">// 함수 정의
fn 함수이름(변수명: &amp;mut 타입) {
    // 실제값을 얻음
    let value = *변수명;
    
    // 변수를 갱신
    *변수명 = 새로운 값;
}

// 함수 호출
함수(&amp;mut 변수);</code></pre>
<p>함수를 정의할 때 변수에 대한 참조자를 전달할 수 있게 <code>변수명: &amp;mut 타입</code>을 지정한다. 그리고 함수를 호출할 때는 <code>함수(&amp;mut 변수)</code>와 같이 변수가 가변이며 참조자라는 것을 명시한다.</p>
<p>함수의 실제 내용에는 변수의 참조자로부터 실제값을 얻기 위해 <code>*변수명</code>과 같이 기술한다. 이것을 '역참조(dereference)'라고 한다. 값을 변경하는 경우에도 역참조를 지정해 <code>*변수명 = 새로운 값;</code>과
같이 기술한다.</p>
<h3 id="인수를-변경하는-예"><a class="header" href="#인수를-변경하는-예">인수를 변경하는 예</a></h3>
<p>다음은 가변 변수를 선언한 뒤 함수를 이용해 원래의 변수값을 변경하는 간단한 예이다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">// 인수의 값에 2를 곱해 반환하는 함수 (1)
fn x2(arg: &amp;mut i32) {
    *arg = *arg * 2;
}

fn main() {
    let mut v = 16;
    x2(&amp;mut v);  // 인수에 2가 곱해진다 (2)
    println!(&quot;{}&quot;, v);
}</code></pre></pre>
<p>컴파일 후 실행해보면 원래 16이었던 <code>v</code>의 값이 2배가 되어 32가 출력된다.</p>
<p>프로그램을 확인해보자. (1)은 인수로 전달된 값에 2를 곱하는 함수다. 여기서 중요한 점은 가변 참조자를 이용할 수 있도록 인수 타입 앞에 <code>&amp;mut</code>을 붙이는 것이다.</p>
<p>(2)에서는 함수를 호출한다. 이 함수에 전달하는 인수는 가변 참조자여야 하기 때문에 <code>&amp;mut</code>을 붙인다.</p>
<h3 id="참조-호출과-값-호출의-차이"><a class="header" href="#참조-호출과-값-호출의-차이">참조 호출과 값 호출의 차이</a></h3>
<p>함수를 호출할 때 인수를 어떻게 전달하느냐에 따라 값 호출(Call by Value)와 참조 호출(Call by Reference)로 나뉜다. 러스트뿐 아니라 다른 일반적인 프로그래밍 언어에서도 이 두 가지 방법이
사용된다.</p>
<p>값 호출은 값 그 자체를 인수로 전달하는 것이며 참조 호출은 변수의 참조자를 사용하는 것이다.</p>
<p>함수를 호출할 때 '값 전달'이 이루어지면 함수의 인수로 지정된 '값'이 그대로 전달되는 것이 아니라 값이 복사되어 함수로 전달된다. 그러므로 함수 안에서 그 값이 어떻게 가공이 되더라도 변수를 호출한 곳에서는
아무런 영향을 받지 않는다. 즉 안전하다. 물론 함수의 인수로 변수를 지정했을 때도 전달되는 것은 변수가 아니라 변수 '값'의 사본이기 때문에 호출한 곳의 변수는 영향을 받지 않는다.</p>
<p>반면 '참조 호출'은 참조자(변수가 가리키는 주소)가 전달된다. 이 경우 함수 안에서 인수의 내용을 변경하면 함수를 호출한 곳의 값도 바뀐다.</p>
<p>러스트에서 참조 전달을 하는 경우 함수의 인수에 참조를 나타내는 <code>&amp;</code>를 지정한다. 러스트에서 값 전달을 하는 경우 소유권 시스템의 규칙이 적용된다. 즉 기본 타입(또는 <code>Copy</code>트레잇이 구현된 타입)이라면 값이
복사되지만 그 외의 타입에서는 소유권이 이동한다.</p>
<blockquote>
<h4 id="println-매크로-사용-방법-정리"><a class="header" href="#println-매크로-사용-방법-정리">println! 매크로 사용 방법 정리</a></h4>
<p><code>println!</code>은 표준 출력으로 임의의 서식을 가진 문자열을 출력하는 매크로다. 러스트 프로그래밍을 하는 데 있어 가장 자주 사용하는 기능 중 하나다. 여기서는 <code>println!</code>매크로 사용 방법을
정리해본다.</p>
<p><strong>소유권 문제가 발생하지 않는다.</strong></p>
<p><code>println!</code>매크로는 소유권과 관련된 문제가 발생하지 않게 구현되어 있다. 다음은 <code>println!</code>을 모방해 <code>echo</code>함수를 만들어 사용하는 예이다. 하지만 이 함수는 소유권이 이동하기 때문에 에러가
발생한다.</p>
<pre><code class="language-rust  noplayground">fn main() {
    let s = &quot;Fast and Robust&quot;.to_string();
    echo(s);  // &lt;- 소유권이 이동한다.
    println!(&quot;{}&quot;, s);
}

// println!을 모방한 함수
fn echo(s: String) {
    println!(&quot;{}&quot;, s);
}</code></pre>
<p>컴파일을 해보면 소유권과 관련된 에러가 발생한다. 하지만 <code>println!</code>매크로를 이용하면 문제가 없으며, 다음과 같이 몇 번이나 같은 값을 이용할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let s = &quot;Fast and Robust&quot;.to_string();
    println!(&quot;{}&quot;, s);  // 소유권이 이동하지 않는다.
    println!(&quot;{}&quot;, s);
}</code></pre></pre>
<p><strong>값을 임의의 장소에 넣을 수 있다.</strong></p>
<p>변수나 값을 문자열 안의 임의의 장소에 넣을 수 있다. 그리고 값을 순서대로 채워넣는 것이 아니라 <code>...{2}...{1}...{0}...</code>과 같이 순서를 임의로 지정할 수도 있다.</p>
<p>예를 들어 연도 표시 방법은 나라에 따라 상이하다. 미국에서는 '월/일/년' 순으로 쓰지만 영국에서는 '일/월/년' 순으로 쓴다. 인수 순서는 변경하지 않고 서식만 변경해서 이런 문제에 대응할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let year = 2023;
    let month = 12;
    let day = 1;
    println!(&quot;KR:{0}/{1}/{2}&quot;, year, month, day);  // 한국
    println!(&quot;US:{1}/{2}/{0}&quot;, year, month, day);  // 미국
    println!(&quot;UK:{2}/{1}/{0}&quot;, year, month, day);  // 영국
}</code></pre></pre>
<p>그리고 다음과 같이 인수에 이름을 붙여서 대입하는 것도 가능하다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let year = 2023;
    let month = 12;
    let day = 1;
    println!(&quot;{yy}년 {mm}월 {dd}일&quot;, dd = day, mm = month, yy = year);
}</code></pre></pre>
<p><strong>서식(format)을 지정할 수 있다.</strong></p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>서식</th><th>설명</th><th>사용 예</th><th>입력</th><th>결과</th></tr></thead><tbody>
<tr><td><code>{:&lt;n}</code></td><td>n자리 왼쪽 정렬</td><td><code>_{:&lt;5}_</code></td><td>30</td><td>_30   _</td></tr>
<tr><td><code>{:&gt;n}</code></td><td>n자리 오른쪽 정렬</td><td><code>_{:&gt;5}_</code></td><td>30</td><td>_   30_</td></tr>
<tr><td><code>{:^n}</code></td><td>n자리 가운데 정렬</td><td><code>_{:5}_</code></td><td>3</td><td>_  3  _</td></tr>
<tr><td><code>{:0&lt;n}</code></td><td>n자리 왼쪽 정렬 후 0으로 채움</td><td><code>_{:0&lt;5}_</code></td><td>12</td><td><em>12000</em></td></tr>
<tr><td><code>{:&gt;0n}</code></td><td>n자리 오른쪽 정렬 후 0으로 채움</td><td><code>_{:&gt;05}_</code></td><td>12</td><td><em>00012</em></td></tr>
<tr><td><code>{:b}</code></td><td>2진수</td><td><code>{:b}</code></td><td>4</td><td>100</td></tr>
<tr><td><code>{:0nb}</code></td><td>2진수에서 n만큼 0으로 채움</td><td><code>{:08b}</code></td><td>4</td><td>00000100</td></tr>
<tr><td><code>{:o}</code></td><td>8진법</td><td><code>{:o}</code></td><td>438</td><td>666</td></tr>
<tr><td><code>{:x}</code></td><td>16진수</td><td><code>{:x}</code></td><td>255</td><td>ff</td></tr>
<tr><td><code>{:0nx}</code></td><td>16진수에서 n만큼 0으로 채움</td><td><code>{:04x}</code></td><td>15</td><td>000f</td></tr>
<tr><td><code>{:.n}</code></td><td>소수점 이하 n자리 표시</td><td><code>{:.2}</code></td><td>3.1415</td><td>3.14</td></tr>
<tr><td><code>{:e}</code></td><td>지수 표시</td><td><code>{:e}</code></td><td>12.34</td><td>1.234e1</td></tr>
<tr><td><code>{:?}</code></td><td>디버그 출력</td><td><code>{:?}</code></td><td>[1,2,3]</td><td>[1, 2, 3]</td></tr>
<tr><td><code>{:#?}</code></td><td>디버그 출력(형태 정렬)</td><td><code>{:#?}</code></td><td>[1,2]</td><td>[(줄바꿈) 1, (줄바꿈) 2, (줄바꿈)]</td></tr>
<tr><td><code>{{</code></td><td>{를 출력</td><td><code>{{</code></td><td>없음</td><td>{</td></tr>
<tr><td><code>}}</code></td><td>}를 출력</td><td><code>}}</code></td><td>없음</td><td>}</td></tr>
<tr><td><code>{:p}</code></td><td>포인터</td><td><code>{:p}</code></td><td>abc</td><td>(예)0x1022c2970</td></tr>
<tr><td><code>\&quot;</code></td><td>&quot;를 출력</td><td><code>\&quot;</code></td><td>없음</td><td>&quot;</td></tr>
<tr><td><code>\\</code></td><td>\를 출력</td><td><code>\\</code></td><td>없음</td><td>\</td></tr>
</tbody></table>
</div>
<blockquote>
<p>서식을 이용해 보자.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 오른쪽 정렬 및 16진수 출력
    println!(&quot;|{:&gt;8}| #{:06x}&quot;, &quot;red&quot;, 0xFF0000);
    println!(&quot;|{:&gt;8}| #{:06x}&quot;, &quot;green&quot;, 0x00FF00);
    println!(&quot;|{:&gt;8}| #{:06x}&quot;, &quot;blue&quot;, 0x0000FF);

    // 디버그 출력
    println!(&quot;|{:&gt;8}| RGB{:?}&quot;, &quot;yellow&quot;, (255, 255, 0));
}</code></pre></pre>
<p>이렇게 <code>println!</code>은 다양한 표현을 할 수 있으므로 활용도가 높다. <code>println!</code>은 표준 출력 용도이지만 문자열을 출력하지 않고 <code>String</code>타입으로 만들어 주는 <code>format!</code>매크로도
있다. <code>format!</code>매크로 역시 <code>println!</code>매크로와 사용 방법은 동일하다. <code>format!</code>매크로 역시 활용도가 높으므로 사용법을 잘 익혀두자.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>#패스트캠퍼스, #국비지원교육, #메가바이트스쿨, #MegabyteSchool, #개발자취업부트캠프, #내일배움카드</p>
<p><em>last edited 2023.02.03</em></p>
<h1 id="러스트의-문자열에-대해-쉬운-설명으로-알아보자"><a class="header" href="#러스트의-문자열에-대해-쉬운-설명으로-알아보자">러스트의 문자열에 대해 쉬운 설명으로 알아보자</a></h1>
<blockquote>
<p>▶ 만들면서 배우는 러스트 프로그래밍 -쿠지라 히코우즈쿠에- ◀ 을 참조하여 정리하였다.</p>
</blockquote>
<p>러스트의 문자열인 <code>String</code>과 <code>&amp;str</code>이 어떻게 다른지 알아보자. 그리고 아시아 언어에서 주로 사용되는 멀티 바이트 문자는 어떻게 다뤄야 할지 확인해보자.</p>
<h2 id="러스트의-문자열"><a class="header" href="#러스트의-문자열">러스트의 문자열</a></h2>
<p>러스트에서 문자열을 다룰 때 <code>String</code> 타입 또는 <code>&amp;str</code>타입을 이용한다. 소스 코드에서 큰따옴표(<code>&quot;</code>)로 문자열을 감싸는 경우 문자열 리터럴 타입은 <code>&amp;str</code>이 된다.</p>
<p><code>&amp;str</code>은 변경이 불가능하다. 그래서 값을 변경하거나 함수의 반환 값으로 사용해야 하는 경우에는 <code>String</code>타입을 사용한다.</p>
<h3 id="string-타입은-벡터"><a class="header" href="#string-타입은-벡터">String 타입은 벡터</a></h3>
<p><code>String</code>타입은 러스트 내부에서 <code>Vec&lt;u8&gt;</code>타입으로 취급된다. <code>Vec</code>은 가변 길이의 배열인 벡터 타입이다. 그리고 <code>u8</code>은 부호가 없는 8비트 정수, 즉 1바이트 정수다. 즉 <code>String</code>타입은
1바이트 단위로 데이터를 확장할 수 있다. 벡터 타입은 힙 메모리에 저장되므로 확장 가능한 문자열 객체이다.</p>
<h3 id="str-타입은-슬라이스"><a class="header" href="#str-타입은-슬라이스">&amp;str 타입은 슬라이스</a></h3>
<p>소스 코드에서 큰따옴표로 감싼 문자열이 <code>&amp;str</code>이다. <code>&amp;str</code>은 러스트 내부에서 슬라이스인 <code>&amp;[u8]</code>타입으로 취급된다. 슬라이스는 배열의 일부 또는 전체를 참조자로 이용할 수 있는 데이터 타입이다. 그리고
참조자이므로 소유권과 관련이 없다.</p>
<h3 id="cc와의-차이점"><a class="header" href="#cc와의-차이점">C/C++와의 차이점</a></h3>
<p>C 언어에서도 문자열은 1바이트 단위의 가변 배열 데이터로 취급한다. 하지만 러스트는 C 언어와 달리 문자열 끝에 <code>NULL</code>(<code>\0</code>)이 없다. 벡터 타입이므로 바이트 수가 기록되어 안전하게 관리된다.</p>
<p><img src="./images/string_01.png" alt="러스트와 C 언어의 문자열 표현 차이" /></p>
<ul>
<li>C 언어에서는 문자열의 끝이 <code>NULL</code>(<code>\0</code>)이므로 문자열 크기를 알려주지 않으면 알 수 없음</li>
<li>러스트에서는 처음부터 문자열의 실제 길이(length)와 메모리에 저장되는 크기(capacity)가 기록됨</li>
</ul>
<h2 id="러스트의-문자열은-utf-8"><a class="header" href="#러스트의-문자열은-utf-8">러스트의 문자열은 UTF-8</a></h2>
<p>러스트에서 다루는 문자열은 <code>String</code> 타입이건 <code>&amp;str</code> 타입이건 문자 인코딩은 UTF-8로 정해져 있다. UTF-8은 Unicode/UCS로 정의된 문자 집합을 표현하는 문자 인코딩(부호화 방식/문자 코드)
이다.</p>
<p>UTF-8의 특징 중 하나는 1글자를 표시하기 위해 1바이트에서 6바이트 사이의 가변 길이를 이용한다는 점이다. 알파벳이나 숫자는 1바이트를 차지하지만 한글이나 일본어는 3바이트를 차지한다.<sup>*</sup></p>
<p><sup>*</sup>유니코드로는 2바이트지만 UTF-8로 표현할 때 3바이트가 된다. 따라서 UTF-8 인코딩을 기본으로 사용하는 러스트에서는 인덱스보다 인덱스의 범위를 지정할 수 있는 슬라이스를 기본적으로
사용한다.</p>
<p><code>String</code>이 <code>Vec&lt;u8&gt;</code>이고 <code>&amp;str</code>이 <code>&amp;[u8]</code>이므로 문자열에서 임의의 1바이트에 접근하는 것도 가능하다. 하지만 <strong>바이트 단위로 접근할 때에는 N바이트째가 N글자에 해당하지 않을 수 있다</strong>는
점도 기억해둬야 한다.</p>
<p>영어 문자열과 바이트열이 대응하는 것을 확인해보자. 'Rust'라는 문자는 다음과 같이 대응된다. 바이트열은 16진수로 표기된다.</p>
<ul>
<li>'Rust'라는 문자열을 바이트로 표시</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>문자열</th><th>R</th><th>u</th><th>s</th><th>t</th></tr></thead><tbody>
<tr><td>바이트열</td><td>52</td><td>75</td><td>73</td><td>74</td></tr>
</tbody></table>
</div>
<p>영어와 숫자는 UTF-8과 ASCII 코드가 동일하다. 그리고 N바이트째 문자는 N번째 문자가 된다.</p>
<p>다음은 '러스트'라는 UTF-8 문자열을 바이트로 표시한 것이다.</p>
<ul>
<li>'러스트'라는 문자열을 바이트로 표시</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>문자열</th><th>러</th><th>스</th><th>트</th></tr></thead><tbody>
<tr><td>바이트열</td><td>eb 9f ac</td><td>ec 8a a4</td><td>ed 8a b8</td></tr>
</tbody></table>
</div>
<p>'러'는 16진수 바이트로 표시하면 'eb 9f ac'의 3바이트, '스'는 'ec 8a a4'의 3바이트, '트'는 'ed 8a b8'의 3바이트다. 즉 문자열에서 2바이트째 값을 가져와도 '스'라는 문자에
해당하는 것이 아니라 '러'의 2바이트째인 '9f'라는 데이터를 가져오는 것이다.</p>
<p>러스트의 문자열 <code>String</code>및 <code>&amp;str</code>에는 문자 단위로 데이터를 가져오는 <code>chars</code> 메서드와 바이트 단위로 데이터를 가져오는 <code>bytes</code> 메서드가 있다. 이 두 메서드의 차이점에 대해 알아보자.</p>
<h3 id="문자열에서-문자-한-개씩-가져오기"><a class="header" href="#문자열에서-문자-한-개씩-가져오기">문자열에서 문자 한 개씩 가져오기</a></h3>
<p>문자열을 하나 만든 뒤 임의의 곳에서 문자 한 개를 가져오는 프로그램을 만들어보자. 러스트는 문자열이 <code>Vec&lt;u8&gt;</code> 타입이라는 것을 알아두자. <code>u8</code>은 부호가 없는 8비트 정수이므로 영어나 숫자 1문자를 저장할
수 있지만 한글은 3바이트(32비트)이므로 저장할 수 없다.</p>
<pre><code class="language-rust  noplayground">fn main() {
    let s = &quot;안녕하세요&quot;;
    println!(&quot;{}&quot;, s[0]);  // 직접 n번째 문자를 가져올 수 없다.
}</code></pre>
<p>위 소스 코드를 컴파일하면 에러가 발생한다.</p>
<pre><code class="language-text">$ rustc str_index_err.rs &amp;&amp; str_index_err
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --&gt; str_index_err.rs:3:22
  |
3 |     println!(&quot;{}&quot;, s[0]);  // 직접 n번째 문자를 가져올 수 없다.
  |                      ^ string indices are ranges of `usize`
  |
  = help: the trait `SliceIndex&lt;str&gt;` is not implemented for `{integer}`
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: &lt;https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings&gt;
  = help: the trait `SliceIndex&lt;[T]&gt;` is implemented for `usize`
  = note: required for `str` to implement `Index&lt;{integer}&gt;`

error: aborting due to previous error
</code></pre>
<p>이 에러 메시지에서 눈여겨볼 부분은 <code>note</code> 부분이다.</p>
<pre><code class="language-text">  = note: you can use `.chars().nth()` or `.bytes().nth()`
  (`.chars().nth()` 또는 `.bytes().nth()`을 이용할 수 있다.)
</code></pre>
<p>러스트에서는 문자열을 저장한 변수에 직접 <code>s[N]</code>과 같은 형태로 접근할 수 없으니, 그 대신 <code>chars</code> 또는 <code>bytes</code> 메서드를 이용하라는 조언이다.</p>
<p><code>chars</code> 메서드는 문자열을 UTF-8 기반으로 1글자씩 분할한 반복자를 반환한다. 그리고 <code>bytes</code> 메서드는 단순히 1바이트 단위로 분할한 반복자를 반환한다.</p>
<p>즉, 1글자씩 가져올 것인지 1바이트씩 가져올 것인지를 명확히 해 그에 맞는 메서드를 선택해야 한다.</p>
<p>러스트의 컴파일 에러 메시지는 이처럼 자세한 정보를 알기 쉽게 표시해주므로 에러 메시지를 읽는 것만으로 대부분의 에러를 해결할 수 있다. 이제 이 조언을 바탕으로 프로그램을 수정해보자. 다음은 <code>chars</code> 메서드를
이용해 1글자를 가져와 출력하는 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let s = &quot;안녕하세요&quot;;
    
    // 첫 1글자를 가져온다.
    let ch = s.chars().nth(0).unwrap();
    println!(&quot;{}&quot;, ch);  // 안
    
    // 3번째 글자를 가져온다.
    let ch = s.chars().nth(2).unwrap();
    println!(&quot;{}&quot;, ch);  // 하
}</code></pre></pre>
<p>컴파일 후 실행해보면 1번째 문자 '안'과 3번째 문자 '하'가 출력된다.</p>
<h2 id="str에-슬라이스-사용"><a class="header" href="#str에-슬라이스-사용">&amp;str에 슬라이스 사용</a></h2>
<p>앞의 문제를 다르게 해결하는 방법도 있다. <code>&amp;str</code>에 대해 슬라이스를 이용하는 방법이다. 문자 단위가 아니라 바이트 단위로 지정한 문자열을 가져올 수 있다. <code>&amp;str</code>에서 특정 부분의 값을 가져올 때 사용한다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 첫 번째 글자를 출력 (1)
    let s2 = &quot;abcdefg&quot;;
    println!(&quot;{}&quot;, &amp;s2[0..1]);  // a
    
    let s = &quot;안녕하세요&quot;;
    
    // 첫 번째 1글자를 출력 (2)
    let ch = &amp;s[..3];
    println!(&quot;{}&quot;, ch);  // 안
    
    // 세 번째 1글자를 출력 (3)
    let ch = &amp;s[6..9];
    println!(&quot;{}&quot;, ch);  // 하
}</code></pre></pre>
<p>컴파일 후 실행하면 <code>&amp;str</code>을 슬라이스해 취득한 데이터가 문자열로 출력된다. 이때 바이트 단위를 잘 지정해야 한다. 올바르지 않게 지정한 경우 컴파일 단계에서 에러가 발생한다.</p>
<ol>
<li>영문 문자열이므로 <code>[0..1]</code> 또는 <code>[..1]</code> 과 같은 형태로 첫 번째 글자의 바이트를 가져올 수 있다.</li>
<li>한글이므로 첫 3바이트(1글자)를 가져온다. 그리고 해당 3바이트를 문자로 출력한다.</li>
<li>3번째 글자인 '하'를 출력하기 위해 <code>[6..9]</code>를 지정해 해당 3바이트를 가져와 문자로 출력한다.</li>
</ol>
<h2 id="str과-string-상호-변환"><a class="header" href="#str과-string-상호-변환">&amp;str과 String 상호 변환</a></h2>
<p><code>&amp;str</code>과 <code>String</code> 타입은 상호 변환이 가능하다. 실제 프로그램으로 확인해보자. 일반적으로 다음과 같은 프로그램은 타입 추론을 이용하므로 타입을 명시하지 않아도 상관없지만 여기서는 타입을 확실히 하기 위해
변수별로 타입을 명시했다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 문자열 리터럴은 &amp;str 타입 (1)
    let ss: &amp;str = &quot;베풀면 반드시 돌아온다&quot;;
    
    // &amp;str은 String으로 변환 (2)
    let so1: String = String::from(ss);
    let so2: String = ss.to_string();
    
    // String을 &amp;str로 변환 (3)
    let ss2: &amp;str = &amp;so1;
    let ss3: &amp;str = so1.as_str();
    
    // 출력
    println!(&quot;{}\n{}\n{}\n{}&quot;, so1, so2, ss2, ss3);
    
    // 참조 타입 포인터 주소를 표시 (4)
    println!(&quot;{:p}\n{:p}&quot;, ss2, ss3);
}</code></pre></pre>
<p>컴파일 후 실행해보면 지정한 문장이 4번 출력되고 <code>&amp;str</code>이 가리키는 참조 주소가 표시된다.</p>
<ol>
<li>문자열 리터럴을 변수 <code>ss</code>에 대입한다. 이때 문자열 리터럴 타입은 <code>&amp;str</code>이다.</li>
<li><code>&amp;str</code>타입을 <code>String</code> 타입으로 변환한다. <code>&amp;str</code>타입을 <code>String</code> 타입으로 변환하는 방법은 소스 코드와 같이 2가지가 있다. 이렇게 해서 <code>String</code> 객체(인스턴스)를 생성한다.</li>
<li><code>String</code>을 다시 <code>&amp;str</code>형식으로 변환한다. 이처럼 <code>&amp;str</code>과 <code>String</code> 변환은 쉽게 할 수 있다.</li>
<li>참조자 확인용 코드로 (3)에서 참조 타입 <code>&amp;str</code>이 현재 가리키는 주소를 출력한다. <code>println!</code>에 <code>&quot;{:p}&quot;</code>를 지정하면 포인터가 가리키는 주소를 출력할 수 있다. '포인터 주소'란 해당 값이
할당된 메모리상의 주소를 말한다.</li>
</ol>
<p><code>String</code> 타입은 힙 메모리에 저장되므로 할당된 주소는 실행할 때마다 달라진다. <code>String</code> 타입의 참조자와 <code>as_str</code> 메서드로 얻을 수 있는 참조자가 같은 주소를 가리키므로 두 값이 같음을 알 수
있다.</p>
<h3 id="문자열을-1바이트씩-출력"><a class="header" href="#문자열을-1바이트씩-출력">문자열을 1바이트씩 출력</a></h3>
<p>상황에 따라서는 문자열을 1바이트씩 잘라 이용하거나 바이너리 데이터를 이용해야 하는 경우도 있다. 여기서는 문자열을 1바이트씩 잘라 내용을 표시해보자. 앞에서 언급한 <code>bytes</code> 메서드를 이용해 문자열을 1바이트씩
표시해본다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let pr = &quot;러스트&quot;;
    
    // 1바이트씩 출력 (1)
    for c in pr.bytes() {
        print!(&quot;{:2x} &quot;, c);
    }
    
    // 바이트 수 구하기 (2)
    println!(&quot;\n바이트 = {}B&quot;, pr.len());
}</code></pre></pre>
<p>프로그램을 실행하면 문자열이 바이트 데이터로 출력된다.</p>
<pre><code class="language-text">$ rustc str_tobytes.rs &amp;&amp; ./str_tobytes
eb 9f ac ec 8a a4 ed 8a b8 
바이트 = 9B
</code></pre>
<ol>
<li><code>for</code> 문으로 <code>bytes</code> 메서드를 이용해 문자열을 1바이트씩 출력한다. <code>bytes</code> 메서드는 반복자를 반환하므로 <code>for</code>문을 이용할 수 있다.</li>
<li><code>len</code> 메서드를 이용해 바이트 수를 표시한다. 러스트에서 실수하기 쉬운 것 중 하나는 <code>&amp;str</code>의 <code>len</code> 메서드다. <code>&amp;str</code>의 <code>len</code>메서드는 문자 길이가 아니라 바이트 길이를 반환한다.</li>
</ol>
<blockquote>
<h4 id="러스트에서-착각하기-쉬운-점---문자-수와-바이트-수"><a class="header" href="#러스트에서-착각하기-쉬운-점---문자-수와-바이트-수">러스트에서 착각하기 쉬운 점 - 문자 수와 바이트 수</a></h4>
<p><code>&amp;str</code>의 <code>len</code> 메서드는 문자열이 아니라 바이트 길이를 반환한다. <code>abc</code>와 같이 영어 문자열에 <code>len</code> 메서드를 이용하면 3을 반환하지만 <code>맛있다</code>라는 한글에 <code>len</code> 메서드를 이용하면 9를
반환한다.</p>
</blockquote>
<h3 id="문자열을-1자씩-출력"><a class="header" href="#문자열을-1자씩-출력">문자열을 1자씩 출력</a></h3>
<p>이번에는 문자열에서 문자 단위로 구분해 출력해보자. 문자 단위를 다루기 위해서는 <code>chars</code> 메서드를 이용한다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let pr = &quot;구슬이 서 말이라도 꿰어야 보배&quot;;

    // 1자씩 표시 (1)
    for c in pr.chars() {
        print!(&quot;[{}]&quot;, c);
    }

    // 글자 수를 세기 (2)
    println!(&quot;\n글자 수 = {}자&quot;, pr.chars().count());

    // Vec&lt;char&gt;로 변환해 처리 (3)
    let pr_chars: Vec&lt;char&gt; = pr.chars().collect();
    println!(&quot;Vec&lt;char&gt; : {:?}&quot;, pr_chars);
    for c in pr_chars.iter() {
        print!(&quot;({})&quot;, c);
    }
    println!(&quot;\n글자 수 = {}자&quot;, pr_chars.len());
}</code></pre></pre>
<p>컴파일 후 실행해보면 문자열 안의 문자가 1자씩 출력된다.</p>
<ol>
<li><code>&amp;str</code>의 <code>chars</code> 메서드와 <code>for</code>문을 이용해 대괄호(<code>[]</code>)에 넣어 1자씩 출력한다.</li>
<li>글자 수를 센다. <code>chars</code> 메서드는 반복자를 반환하므로 <code>count</code> 메서드를 이용하면 요소의 수를 셀 수 있다.</li>
<li><code>chars</code> 메서드를 이용해 <code>Vec&lt;char&gt;</code> 타입으로 변환한 뒤 문자열을 처리한다. 벡터의 <code>iter</code> 메서드와 <code>for</code> 문을 이용해 1자씩 처리할 수 있다. 여기서 변수 <code>pr_chars</code>는 이미
글자별로 분리된 벡터 타입이므로 <code>len</code> 메서드를 이용하면 바이트 수가 아니라 글자 수(즉 벡터의 길이)를 반환한다.</li>
</ol>
<p><code>u8</code>이 기호 없는 8비트 정수(1바이트)로 문자를 표현하는 반면 <code>char</code> 타입은 32비트(4바이트)로 1문자를 표시한다. 이 부분에서도 러스트의 언어적 성격을 엿볼 수 있다. 처음부터 <code>Vec&lt;char&gt;</code>를
문자열 내부 표현으로 하는 것이 아니라 <code>Vec&lt;u8&gt;</code>을 문자열로 표현한다. 그리고 필요에 따라 <code>Vec&lt;char&gt;</code>로 변환해 처리 한다.</p>
<h2 id="라이프타임"><a class="header" href="#라이프타임">라이프타임</a></h2>
<p>수명(Lifetime)이라면 보통 생애, 생존 기간을 의미한다. 러스트에서의 라이프타임은 값을 참조할 수 있는 범위(Scope)를 의미한다. 라이프타임은 아포스트로피(<code>'</code>)를 붙여 표현한다. 그리고 대부분
소문자만을 이용하여 짧은 영문자 한 개(<code>a</code> 등)를 이용하는 경우가 많다.</p>
<p>값이 일반적인 라이프타임 범위를 가지고 있다면 컴파일러는 값의 유효 범위(라이프타임)를 추론할 수 있다. 따라서 라이프타임 지시자를 생략할 수 있다. 하지만 라이프타임 지시자를 반드시 지정해야 하는 경우도 있다.</p>
<p>참고로 가장 긴 라이프타임을 가지는 것은 <code>'static</code>이다. 이것은 러스트 프로그램이 시작할 때부터 종료될 때까지 존재한다. 문자열 리터럴의 타입은 <code>&amp;str</code>이지만 라이프타임을 명시하는
경우 <code>&amp;'static str</code>과 같이 기술한다.</p>
<p>다음은 <code>echo</code>함수를 정의해서 이용하는 프로그램으로 <code>&amp;'static str</code>타입을 인수로 받아 처리한다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">// &amp;'static str을 이용하는 함수 (1)
fn echo(s: &amp;'static str) {
    println!(&quot;{}&quot;, s);
}

fn main() {
    // 문자열 리터럴(&amp;'static str)을 지정 (2)
    echo(&quot;웅변은 은이요&quot;);
    echo(&quot;침묵은 금이다&quot;);
    
    // 아래 주석 부분은 에러가 발생한다 (3)
    // let s = String::from(&quot;테스트&quot;);
    // echo(&amp;s);
}</code></pre></pre>
<p>컴파일 후 실행해보면 <code>echo</code>함수 안에 지정한 문자열이 출력된다.</p>
<ol>
<li>함수를 보면 라이프타임 지시자를 붙여 <code>&amp;'static str</code>을 인수로 지정했다. 즉 <code>&amp;str</code>타입이며 <code>'static</code>라이프타임을 가진 참조자만을 인수로 사용할 수 있다.</li>
<li>큰따옴표로 이루어진 문자열을 지정했는데 이는 <code>&amp;str</code>타입이다. 그리고 <code>&amp;str</code>타입은 <code>'static</code>이 생략됐다. 즉 함수의 인수로 라이프타임이 <code>'static</code>인 문자열 리터럴을 지정했다. 따라서
문제없이 문자열 리터럴 내용이 출력된다.</li>
</ol>
<p>주석 처리된 (3) 부분의 주석을 해제한 뒤 실행해보자. 변수 <code>s</code>의 참조자인 <code>&amp;s</code>는 <code>main</code>함수 안에서만 살아있을 수 있다. 따라서 <code>'static</code>보다 짧은 라이프타임을 가지므로 <code>echo</code>함수에서
호출하면 에러가 발생한다. 함수의 인수에 라이프타임 지시자를 지정한 경우 그보다 짧은 라이프타임을 가진 값을 사용할 수 없기 때문이다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>#패스트캠퍼스, #국비지원교육, #메가바이트스쿨, #MegabyteSchool, #개발자취업부트캠프, #내일배움카드</p>
<p><em>last edited 2023.02.03</em></p>
<h1 id="러스트의-문자열-처리에-익숙해지기"><a class="header" href="#러스트의-문자열-처리에-익숙해지기">러스트의 문자열 처리에 익숙해지기</a></h1>
<blockquote>
<p>▶ 만들면서 배우는 러스트 프로그래밍 -쿠지라 히코우즈쿠에- ◀ 을 참조하여 정리하였다.</p>
</blockquote>
<p>앞 섹션에서는 <code>String</code>와 <code>&amp;str</code>을 이용한 기본적인 문자열 처리를 다뤘다. 이 섹션에서는 앞에서 배운 내용을 바탕으로 조금 더 실용적인 문자열 처리 방법을 알아보자.</p>
<h2 id="문자열을-바이너리-에디터-형태로-출력하기"><a class="header" href="#문자열을-바이너리-에디터-형태로-출력하기">문자열을 바이너리 에디터 형태로 출력하기</a></h2>
<p>먼저 문자열을 바이너리 편집기에서처럼 출력하는 프로그램을 만들어보자. 지정한 문자열을 16진수로 변환해 4바이트씩 끊어 출력하는 것이다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    hex_dump(&quot;성공하는 사람은 송곳처럼 어느 한 점을 향하여 일한다.&quot;);
}

fn hex_dump(s: &amp;str) {
    // 1바이트씩 표시 (1)
    for (i, c) in s.bytes().enumerate() {
        // 주소를 표시
        if i % 16 == 0 {
            print!(&quot;{:08x}|&quot;, i);
        }
        
        // 4자리씩 끊어 문자를 표시
        if i % 4 == 3 {
            print!(&quot;{:02x}}&quot;, c);
        } else {
            print!(&quot;{:02x} &quot;, c);
        }
        
        // 16바이트마다 줄바꿈
        if i % 16 == 15 {
            println!();
        }
    }
    
    println!();
}</code></pre></pre>
<p>컴파일 후 실행해보면 문자열을 1바이트씩 잘라 한 줄에 16바이트의 16진수 데이터를 출력한다.</p>
<p>앞 섹션에서 설명한 것처럼 <code>&amp;str</code> 타입의 <code>bytes</code> 메서드는 UTF-8 문자열을 1바이트씩 자른 반복자를 반환한다. 반복자에 <code>enumerate</code> 메서드를 이용하면 반복자에 인덱스를 붙인 데이터를 반환한다.</p>
<h2 id="부분-문자열-얻기"><a class="header" href="#부분-문자열-얻기">부분 문자열 얻기</a></h2>
<p>문자열에서 부분 문자열을 추출하는 방법을 살펴보자. 문자열 처리를 할 때 부분 문자열만을 이용하는 경우는 자주 일어난다.</p>
<p>부분 문자열을 얻는 방법은 다양하지만 가장 간단한 슬라이스를 이용한 방법은 다음과 같이 생각할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let pr = &quot;지혜는 무기보다 가치가 있다.&quot;;

    // 앞의 2글자(6바이트)를 얻기 (1)
    println!(&quot;앞 2글자: {}&quot;, &amp;pr[0..6]);

    // '무기' 부분을 얻기 (2)
    println!(&quot;4-5번째 글자: {}&quot;, &amp;pr[10..16]);
}</code></pre></pre>
<ol>
<li>문장의 제일 앞 2글자를 가져와 출력한다. <code>&amp;str</code>의 슬라이스는 문자열이 아니라 바이트를 지정한다. 앞에서 설명한 것처럼 한글은 1글자당 3바이트다. 따라서 <code>&amp;pr[0..6]</code>으로 6바이트까지의 데이터를
지정한다.</li>
<li>여기서는 약간 다른데, 공백이 한 칸 들어있으므로 <code>9..15</code>가 아니라 <code>10..16</code>이 된다. 공백은 영어나 숫자와 같이 1바이트이기 때문이다.</li>
</ol>
<p>현재 프로그램에는 문제가 있다. 띄어쓰기는 1바이트가 사용되므로 문장이 변경되는 경우 어디에서 띄어쓰기가 발생하느냐에 따라 제대로 처리가 안 될 수 있다. 그리고 이모지의 경우 3~4바이트를 이용하므로 역시 문제가
발생할 가능성이 있다.</p>
<div class="table-wrapper"><table><thead><tr><th>문자 종류</th><th>예</th><th>바이트</th></tr></thead><tbody>
<tr><td>영어, 숫자, 특수문자</td><td>a / b / A / #</td><td>1바이트</td></tr>
<tr><td>한국어</td><td>가 / 양 / 화</td><td>3바이트</td></tr>
<tr><td>일본어(가나 / 한자)</td><td>あ / ン / 愛</td><td>3바이트</td></tr>
<tr><td>이모지</td><td>🦀/ 😆 / ⚡ / 🛡 / 🐘</td><td>3~4바이트</td></tr>
</tbody></table>
</div>
<h3 id="슬라이스에서-잘못된-범위를-지정한-경우"><a class="header" href="#슬라이스에서-잘못된-범위를-지정한-경우">슬라이스에서 잘못된 범위를 지정한 경우</a></h3>
<p>문자 범위 지정이 잘못됐다면 프로그램은 패닉 에러가 발생해 강제로 종료된다.</p>
<p>다음은 범위를 잘못 지정한 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let pr = &quot;🦀😆⚡🛡🐘&quot;;
    
    // 앞의 2글자(6바이트)를 얻기 (1)
    println!(&quot;앞 2글자: {}&quot;, &amp;pr[0..6]);
}</code></pre></pre>
<p>컴파일은 문제없이 완료되지만 프로그램을 실행하면 패닉 에러가 발생하고 종료된다.</p>
<p>그렇다면 어떻게 문자열의 일부분을 취득해야 할까?</p>
<h3 id="chars와-enumberate를-이용해-부분-문자열을-얻는-방법"><a class="header" href="#chars와-enumberate를-이용해-부분-문자열을-얻는-방법">chars와 enumberate를 이용해 부분 문자열을 얻는 방법</a></h3>
<p>간단한 해결 방법은 <code>chars</code> 메서드를 이용해 문자 단위로 다루는 것이다. 다음은 <code>enumerate</code> 메서드를 이용해 인덱스를 만들어 문자열을 취득하는 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    pr = &quot;🦀😆⚡🛡🐘&quot;;

    // 앞의 2글자를 얻기 (1)
    let mut sub1 = String::new();
    for (i, c) in pr.chars().enumerate() {
        if i &lt; 2 {
            sub1.push(c);
            continue;
        }
        break;
    }
    println!(&quot;앞 2글자: {}&quot;, sub1);

    // '🦀😆' 부분 얻기 (2)
    let mut sub2 = String::new();
    for (i, c) in pr.chars().enumerate() {
        if 3 &lt;= i &amp;&amp; i &lt;= 4 {
            sub2.push(c);
        }
        println!(&quot;4-5번째 문자: {}&quot;, sub2);
    }
}</code></pre></pre>
<p>이번에는 문제없이 실행된다.</p>
<ol>
<li>앞의 2글자를 얻는다. <code>enumerate</code> 메서드를 사용하면 <code>char</code> 데이터와 몇 번째 문자인지를 나타내는 인덱스를 얻을 수 있다. 이 인덱스(변수 <code>i</code>)를 확인해 2 미만이면 부분 문자열을 저장할
변수 <code>sub1</code>에 1문자씩 추가한다. <code>String</code> 타입의 <code>push</code>메서드를 이용하면 <code>char</code>타입 문자를 추가할 수 있다.</li>
<li>마찬가지 방법을 사용한다. 여기서는 4~5번째 문자를 얻어와야 하므로 <code>for</code> 문 안에 있는 <code>if</code> 조건이 바뀐다. 조건에 맞는 위치에 존재하는 문자를 변수 <code>sub2</code>에 추가한다.</li>
</ol>
<h3 id="조금-더-영리하게-부분-문자열-얻기"><a class="header" href="#조금-더-영리하게-부분-문자열-얻기">조금 더 영리하게 부분 문자열 얻기</a></h3>
<p><code>enumerate</code> 메서드를 사용하는 방법도 나쁘지는 않지만 <code>for</code> 문을 이용해 반복해야 하며, 코드가 중복된다. 이번에는 조금 더 영리한 방법을 2가지 소개한다. 2가지 다 문자열을 문자 단위로
조작하므로 <code>chars</code> 메서드를 이용한다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let pr = &quot;지혜는 무기보다 가치가 있다.&quot;;

    // 앞의 2글자 부분 문자열 얻기 (1)
    let sub3: String = pr.chars().take(2).collect();
    println!(&quot;앞 2글자: {}&quot;, sub3);

    // '무기' 부분 문자열 얻기 (2)
    let pr_chars: Vec&lt;char&gt; = pr.chars().collect();  // 변환

    // 4-5번째 문자열 얻기
    let sub_chars = &amp;pr_chars[4..=5];  // 슬라이스

    // 슬라이스를 문자열로 변환
    let sub4: String = sub_chars.into_iter().collect();
    println!(&quot;4-5번째 글자: {}&quot;, sub4);
}</code></pre></pre>
<p>실행해보면 '지혜', '무기'가 출력되는 것을 확인할 수 있다.</p>
<ol>
<li>앞의 2글자를 부분 문자열로 가져와 출력한다. <code>&amp;str</code>의 <code>chars</code>메서드는 반복자를 반환하므로 여기서 <code>take(2)</code>라고 지정하면 앞의 2글자를 가져올 수 있다. 변수는 아직 반복자
상태이므로 <code>collect</code> 메서드를 이용해 문자열로 변환한다. <code>take</code> 메서드를 이용해 짧은 코드로 처리를 할 수 있었다. <code>take</code>는 반복자에서 지정한 개수만큼의 데이터를 불러오므로 데이터 일부를
가져오는 데 유용하다.</li>
<li>'무기' 부분의 문자열을 가져오기 위해 5번째와 6번째 문자열을 가져온다. 공백도 하나의 문자로 카운트되기 때문에 5번째 글자가 '무'가 된다. <code>&amp;str</code> 데이터를 <code>Vec&lt;char&gt;</code>로 변환한
뒤 <code>&amp;pr_chars[4..=5]</code>와 같이 슬라이스해 데이터를 가져온다. 이 때의 데이터는 ['무', '기']가 되므로 <code>into_iter().collect</code>메서드를 이용해 <code>String</code>으로 변환한다.
여기서 중요한 부분은 <code>Vec&lt;char&gt;</code>로 변환하는 것이다. 이렇게 해서 문자 단위로 조작할 수 있다. 그리고 <code>Vec&lt;char&gt;</code>의 슬라이스를 문자열로 변환하는 방법도 잘 기억해두자.
참고로 <code>&amp;pr_char[4..=5]</code>는 <code>&amp;pr_char[4..6]</code>으로 써도 같은 의미다.</li>
</ol>
<h2 id="문자열-검색"><a class="header" href="#문자열-검색">문자열 검색</a></h2>
<p>다음으로 <code>&amp;str</code> 타입 문자열을 검색해보자. <code>find</code> 메서드를 이용하면 검색을 할 수 있다. 다음은 문자열 안에서 '귤'(<code>char</code> 타입)이라는 글자가 어디에 있는지, 그리고 '바나나'(<code>&amp;str</code> 타입)
라는 단어가 어디에 있는지 검색하는 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let s = &quot;제주도의 특산품 중 귤은 겨울에 많이 먹을 수 있다.&quot;;

    // '귤'을 검색 (1)
    match s.find('귤') {
        Some(i) =&gt; println!(&quot;귤 = {}B&quot;, i),
        None =&gt; println!(&quot;'귤'이라는 단어는 없습니다.&quot;),
    };

    // &quot;바나나&quot;를 검색 (2)
    match s.find(&quot;바나나&quot;) {
        Some(i) =&gt; println!(&quot;바나나 = {}B&quot;, i),
        None =&gt; println!(&quot;'바나나'라는 단어는 없습니다.&quot;),
    };
}</code></pre></pre>
<p>컴파일 후 실행해보면 '귤'이라는 글자가 어디에 있는지 표시해준다.</p>
<ol>
<li><code>find</code> 메서드를 이용해 '귤'(<code>char</code> 타입)이 어디에 있는지 검색한다. <code>find</code> 메서드는 <code>Option</code> 타입이므로 <code>Some(위치)</code> 또는 <code>None</code>을 반환한다. 그래서 <code>match</code>문을
이용해 처리한다. <code>Some(위치)</code>는 해당 글자가 위치한 곳의 '바이트-1'을 반환한다(배열과 같이 0바이트에서 시작한다). 즉 '제'라는 문자를 검색하면 <code>Some(0)</code>이 반환된다.</li>
<li><code>find</code>를 이용해 '바나나'(<code>&amp;str</code> 타입)를 검색한다. 문자열에 '바나나'가 포함되지 않았으므로 <code>None</code>이 반환된다.</li>
</ol>
<h3 id="클로저를-지정한-검색"><a class="header" href="#클로저를-지정한-검색">클로저를 지정한 검색</a></h3>
<p><code>find</code> 메서드에서는 클로저를 지정할 수도 있다. 영단어 등을 검색할 때 알파벳을 모두 소문자로 변경해 대소문자를 신경 쓰지 않고도 검색이 되게 하는 등 유연한 검색 기능을 만들 수 있다.</p>
<p>다음은 문자열을 대문자로 변환한 뒤 검색해 가장 처음에 나오는 'S'의 위치를 찾는 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 변수 s에 문장을 대입
    let s = format!(&quot;{}{}&quot;,
                    &quot;There is more hapiness in giving &quot;,
                    &quot;than there is in receiving.&quot;);

    // 클로저로 검색
    let res = s.find(|c: char| c.to_ascii_uppercase() == 'S');
    match res {
        Some(i) =&gt; println!(&quot;S={}B&quot;, i),
        None =&gt; println!(&quot;None&quot;),
    };
}</code></pre></pre>
<p>컴파일 후 실행해보면 영어 문장에서 가장 처음 'S'가 등장하는 위치가 표시된다.</p>
<ol>
<li><code>format!</code> 매크로를 이용해 두 문장을 하나로 합쳤다. 큰따옴표로 둘러싸인 문자열 리터럴은 모두 <code>&amp;str</code>이므로 <code>+</code> 연산자로는 결합할 수 없지만 <code>format!</code> 매크로를 이용하면 쉽게 결합할 수
있다.</li>
<li><code>find</code> 메서드에 클로저를 이용해 검색한다. 여기서 클로저에 '문장에 있는 알파벳을 대문자로 바꿔서 S가 되는 것'을 찾는다는 조건을 넣었다. 이처럼 <code>find</code> 메서드에 클로저를 이용하면 <code>for</code>
문이나 <code>if</code>문을 조합하지 않고도 쉽게 검색할 수 있다.</li>
</ol>
<h3 id="문자열-치환"><a class="header" href="#문자열-치환">문자열 치환</a></h3>
<p>다음으로 문자열 치환에 도전해보자. 문자열에서 1문자만 치환하려면 <code>replace</code> 메서드를 이용한다.</p>
<p>다음은 문자열 치환 예다. 원래 문장에서 2곳을 치환한다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let s = &quot;내 자신에 대한 자신감을 잃으면 온 세상이 나의 적이 된다.&quot;;

    // 문자열 치환 (1)
    let s2 = s.replace(&quot;잃으면&quot;, &quot;가지면&quot;);
    let s3 = s.replace(&quot;적이&quot;, &quot;편이&quot;);

    // 치환 전과 후를 출력 (2)
    println!(&quot;수정 전 : {}\n수정 후 : {}&quot;, s, s3);
}</code></pre></pre>
<ol>
<li><code>&amp;str</code>의 <code>replace</code>메서드를 이용해 문자열의 일부를 치환한다. 그리고 (2) 부분에서는 치환 전과 치환 후의 문자열을 출력한다.</li>
</ol>
<p><code>&amp;str</code> 타입은 값을 변경할 수 없으므로 치환한 후의 문자열은 <code>String</code> 타입이 된다. 즉, <code>s2</code>와 <code>s3</code>은 <code>String</code> 타입이다. 여기서 알 수 있듯 <code>&amp;str</code> 타입과 <code>String</code> 타입
모두 <code>replace</code> 메서드를 사용할 수 있다.</p>
<h2 id="섀도잉---스코프-안에서-변수-재선언"><a class="header" href="#섀도잉---스코프-안에서-변수-재선언">섀도잉 - 스코프 안에서 변수 재선언</a></h2>
<p>앞의 예에서 치환 후의 문자열만 사용한다면 치환할 때마다 변수를 다시 선언하는 것은 비효율적이다. 러스트에서는 섀도잉(Shadowing)이라는 기능이 있어 같은 스코프 안에서 이전에 선언한 변수와 같은 이름의 새
변수를 선언할 수 있다. 같은 이름을 가진 변수를 선언하면 이전에 선언한 변수의 값이 숨겨지고(shadowed) 새로 선언된 변수의 값을 갖게 된다.</p>
<p>다음은 앞 예제에서 섀도잉을 이용해 변수 이름을 바꾸지 않고 값을 바꾸는 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let s = &quot;내 자신에 대한 자신감을 잃으면 온 세상이 나의 적이 된다.&quot;;
    let s = s.replace(&quot;잃으면&quot;, &quot;가지면&quot;);
    let s = s.replace(&quot;적이&quot;, &quot;편이&quot;);
    println!(&quot;{}&quot;, s);
}</code></pre></pre>
<p>프로그램을 실행해보자. 섀도잉으로 인해 같은 이름의 변수를 여러 번 사용했지만 문제없이 실행되는 것을 알 수 있다.</p>
<p>섀도잉을 이용하면 잠시 사용하기 위한 변수를 만드는 수고를 덜 수 있다. 그리고 가변 변수를 이용하는 부분을 줄일 수도 있다.</p>
<p>예를 들어 변수 <code>v</code>에 덧셈을 한 번 하기 위해 <code>v</code>를 가변 변수로 선언하는 것은 좋은 생각은 아니다. 이럴 때 섀도잉을 이용하면 불필요한 가변 변수를 쓰지 않고도 해결할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 섀도잉을 이용하지 않음 (1)
    {
        let mut v = 300;  // v를 가변 변수로 선언
        v = v + 5;
        println!(&quot;{}&quot;, v);
    }

    // 섀도잉을 이용 (2)
    {
        let v = 300;  // v는 불변 변수
        let v = v + 5;
        println!(&quot;{}&quot;, v);
    }
}</code></pre></pre>
<ol>
<li>변수 <code>v</code>를 가변 변수로 선언했다. 덧셈 한 번을 위해 가변 변수를 선언하면 나중에 실수로 <code>v</code>의 값을 변경하는 등 버그의 원인이 될 수 있다.</li>
<li>섀도잉을 이용하므로 불변 변수를 이용해도 문제가 없다. 섀도잉을 하면 섀도잉 전의 값은 이용할 수 없지만 변수는 여전히 불변이므로 안전하다.</li>
</ol>
<h2 id="문자열-분할"><a class="header" href="#문자열-분할">문자열 분할</a></h2>
<p>문자열을 자를 때는 특정 위치에서 자르거나 구분자로 사용할 문자로 자를 수 있다.</p>
<p>다음은 전화번호 031-943-2839에서 지역번호 031을 제외한 '943-2839'을 국번과 사번으로 나누는 예다. 슬라이스를 제외하고 3가지 메서드를 이용해 분할한다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 전화번호 지정
    let telno = &quot;943-2839&quot;;

    // 슬라이스로 분할 (1)
    println!(&quot;-- 슬라이스 --&quot;);
    println!(&quot;국번: {}&quot;, &amp;telno[..3]);
    println!(&quot;사번: {}&quot;, &amp;telno[4..]);

    // split_at으로 분할 (2)
    println!(&quot;--- split_at ---&quot;);
    let (telno1, telno2) = telno.split_at(3);
    let (telno2, telno3) = telno2.split_at(1);
    println!(&quot;국번: {}&quot;, telno1);
    println!(&quot;구분: {}&quot;, telno2);
    println!(&quot;사번: {}&quot;, telno3);

    // split_off로 분할 (3)
    println!(&quot;-- split_off --&quot;);
    let mut telno1 = String::from(telno);
    let mut telno2 = telno1.split_off(3);
    let telno3 = telno2.split_off(1);
    println!(&quot;국번: {}&quot;, telno1);
    println!(&quot;구분: {}&quot;, telno2);
    println!(&quot;사번: {}&quot;, telno3);

    // split으로 분할 (4)
    println!(&quot;-- split --&quot;);
    let telno_a: Vec&lt;&amp;str&gt; = telno.split('-').collect();
    println!(&quot;국번: {}&quot;, telno_a[0]);
    println!(&quot;사번: {}&quot;, telno_a[1]);
}</code></pre></pre>
<p>컴파일 후 실행해보면 국번과 사번이 나뉘어 출력되는 것을 확인할 수 있다.</p>
<ol>
<li>슬라이스를 이용한 분할이다. 직접 범위를 지정해 추출한다.</li>
<li><code>split_at</code> 메서드를 이용한다. 임의의 위치를 지정해 해당 위치를 기준으로 문자열을 분리해 튜플 <code>(&amp;str, &amp;str)</code> 타입을 반환한다.</li>
<li><code>split_off</code> 메서드를 이용한 방법이다. <code>split_off</code>를 이용하면 인수로 지정한 바이트 수를 남겨 그 값을 반환한다. 먼저 첫 변수 <code>telno1</code>에 <code>String::from</code>을 이용해 전화번호
문자열을 대입한다. 그리고 <code>telno1.split_off(3)</code>을 하면 처음 3바이트인 943가 <code>telno1</code>에 남고 나머지 (-2839) 부분은 <code>telno2</code>에 대입된다.
그리고 <code>telno2.split_off(1)</code>로 <code>telno2</code>에 하이픈(<code>-</code>)을 남기고 <code>telno3</code>에 나머지 부분인 2839가 대입된다.</li>
<li><code>split</code> 메서드를 이용하는 방법이다. <code>split</code> 메서드는 구분할 기준 문자를 지정하면 해당 문자를 기준으로 문자열이 분리된다. <code>split</code> 메서드는 <code>Vec&lt;&amp;str&gt;</code> 타입을 반환한다. 이 메서드는
구분자는 출력하지 않는다.</li>
</ol>
<h2 id="euc-kr로-인코딩된-파일-읽고-쓰기"><a class="header" href="#euc-kr로-인코딩된-파일-읽고-쓰기">EUC-KR로 인코딩된 파일 읽고 쓰기</a></h2>
<p>러스트는 UTF-8을 이용해 문자열을 처리하므로 EUC-KR 같이 UTF-8로 인코딩되지 않은 파일을 다루기 위해서는 변환 작업을 해야 한다. 지금은 대부분 UTF-8을 이용하지만, 예전 버전 윈도우에서는 별도로
지정하지 않는 이상 EUC-KR 인코딩으로 저장된다. 여기서는 EUC-KR 문서를 다루기 위해 <code>encoding_rs</code>라는 크레이트를 이용한다.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use encoding_rs;
use std::fs;
use std::fs::File;
use std::io::Write;

fn main() {
    // 저장할 파일 이름 지정
    let filename = &quot;test-euckr.txt&quot;;

    // EUC_KR로 저장 (1)
    save_euckr(filename, &quot;맛있게 먹으면 0칼로리&quot;);

    // EUC_KR 파일 읽어오기 (2)
    let s = load_euckr(filename);
    println!(&quot;{}&quot;, s);
}

fn save_euckr(filename: &amp;str, text: &amp;str) {
    // EUC_KR로 인코드 (3)
    let (enc, _, _) = encoding_rs::EUC_KR.encode(text);
    let buf = enc.into_owned();

    // 파일 생성 및 내용 쓰기 (4)
    let mut file = File::create(filename).expect(&quot;생성&quot;);
    file.write(&amp;buf[..]).expect(&quot;쓰기&quot;);
}

fn load_euckr(filename: &amp;str) -&gt; String {
    // 파일을 한 번에 읽어들임 (5)
    let buf = fs::read(filename).expect(&quot;읽기&quot;);

    // EUC_KR로 디코드 (6)
    let (dec, _, _) = encoding_rs::EUC_KR.decode(&amp;buf);
    dec.into_owned()
}</code></pre></pre>
<p>프로그램을 빌드한 뒤 실행해보면, 파일이 하나 생성되고 파일의 내용이 출력된다. 실행 전에는 없던 <code>test-euckr.txt</code> 파일이 생성된 것을 확인할 수 있다.</p>
<pre><code class="language-text">$ cargo run
   Compiling cfg-if v1.0.0
   Compiling encoding_rs v0.8.31                                                                                                                                                                                                  
   Compiling enc_save_load v0.1.0 (C:\Users\jerok\projects\rust\rust_programming_examples\src\ch03\enc_save_load)                                                                                                                 
    Finished dev [unoptimized + debuginfo] target(s) in 3.06s                                                                                                                                                                     
     Running `target\debug\enc_save_load.exe`
맛있게 먹으면 0칼로리
</code></pre>
<p>소스 코드의 (1)과 (2)는 지정한 파일 이름으로 저장하는 함수와 저장된 파일을 불러오는 함수를 호출하는 부분이다.</p>
<ol start="3">
<li>러스트이 문자열을 EUC-KR로 인코딩한다. <code>encoding_rs</code>는 다양한 언어로 인코딩을 할 수 있다. <code>encode</code> 메서드를 이용해 인코딩을 하면 <code>(Cow&lt;[u8]&gt; Encoding, bool)</code>
형태의 튜플을 반환한다. 이 중 <code>Cow&lt;[u8]&gt;</code>은 EUC-KR로 인코딩된 바이너리 배열 슬라이스다. <code>Cow</code>는 데이터 참조와 소유가 모두 가능한 객체다. <code>into_owned</code> 메서드를 호출해 소유권을
가져올 수 있다.</li>
<li>바이너리 배열을 파일로 저장한다. <code>File::create</code>로 파일을 생성하고 <code>file.write</code>를 이용해 데이터를 파일에 쓴다. <code>create</code>와 <code>write</code> 메서드에 <code>expect</code>를 지정해 작업이
실패하면 어느 부분에서 에러가 발생했는지 바로 알 수 있게 했다.</li>
<li><code>fs::read</code>를 이용해 파일에서 바이트 배열을 읽는다.</li>
<li>EUC-KR의 <code>decode</code> 메서드를 이용해 바이너리 배열을 UTF-8로 디코드한다. <code>decode</code>의 반환값은 <code>(Cow&lt;str&gt;, Encoding, bool)</code> 형태의 튜플이다. <code>Cow&lt;str&gt;</code>
에 <code>into_owned</code>메서드를 이용해 소유권을 획득하면 <code>String</code> 타입 문자열을 얻을 수 있다.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="공통-동작을-정의하는-트레잇"><a class="header" href="#공통-동작을-정의하는-트레잇">공통 동작을 정의하는 트레잇</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
