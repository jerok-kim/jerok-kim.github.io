<!DOCTYPE HTML>
<html lang="kr" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fast⚡ and Robust🛡️</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="home.html">Home</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">토막글</li><li class="chapter-item expanded "><a href="rust.html"><strong aria-hidden="true">1.</strong> Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust_ownership.html"><strong aria-hidden="true">1.1.</strong> 소유권 시스템</a></li><li class="chapter-item expanded "><a href="rust_borrowing.html"><strong aria-hidden="true">1.2.</strong> 빌림과 참조</a></li><li class="chapter-item expanded "><a href="rust_string.html"><strong aria-hidden="true">1.3.</strong> 러스트의 문자열</a></li><li class="spacer"></li><li class="spacer"></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fast⚡ and Robust🛡️</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jerok-kim/jerok-kim.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="프로젝트들"><a class="header" href="#프로젝트들">프로젝트들</a></h2>
<hr />
<h2 id="공부-정리글-모음"><a class="header" href="#공부-정리글-모음">공부 정리글 모음</a></h2>
<h3 id="c"><a class="header" href="#c">C</a></h3>
<ul>
<li><strong><a href="https://jerok-kim.github.io/do_it_c/">Do it C 입문</a></strong>. </li>
</ul>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<ul>
<li><strong><a href="https://jerok-kim.github.io/rust_in_action/">Rust in Action</a></strong>.</li>
<li><strong><a href="https://jerok-kim.github.io/rust_lang_book/">Rust Programming Language</a></strong>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-1"><a class="header" href="#rust-1">Rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>#패스트캠퍼스, #국비지원교육, #메가바이트스쿨, #MegabyteSchool, #개발자취업부트캠프, #내일배움카드</p>
<p><em>last edited 2023.01.26</em></p>
<h1 id="러스트의-소유권-시스템에-대해-쉬운-설명으로-알아보자"><a class="header" href="#러스트의-소유권-시스템에-대해-쉬운-설명으로-알아보자">러스트의 소유권 시스템에 대해 쉬운 설명으로 알아보자</a></h1>
<blockquote>
<p>▶ 만들면서 배우는 러스트 프로그래밍 -쿠지라 히코우즈쿠에- ◀ 을 참조하여 정리하였다.</p>
</blockquote>
<p>러스트에는 메모리 안전성을 확보하기 위한 '소유권(ownership)'이라는 시스템이 있다. 이는 다른 언어에서는 없는 개념으로 러스트를 배우는데 있어서 첫번째 난관이 된다.</p>
<h2 id="소유권-시스템이란-무엇인가"><a class="header" href="#소유권-시스템이란-무엇인가">소유권 시스템이란 무엇인가</a></h2>
<p>러스트는 안전성을 가지면서도 효율적인 고속 프로그래밍 언어다. 마찬가지로 효율적인 프로그래밍 언어인 C 언어는 메모리 관리가 어렵고, 메모리와 관련된 버그가 많이 발생한다. 안전성 향상에 큰 역할을 하는 것이 바로
이 소유권 시스템이다. 소유권 시스템은 러스트의 가장 중심이 된다고 해도 과언이 아니다.</p>
<h3 id="소유권-시스템을-간단히-표현하면"><a class="header" href="#소유권-시스템을-간단히-표현하면">소유권 시스템을 간단히 표현하면</a></h3>
<p>소유권 시스템은 간단히 말하면 <strong>확보한 메모리를 사용이 끝난 시점에 자동으로 파기하는 기능</strong>이다. 확보한 메모리를 이용할 수 있는 범위를 명확히 한정 지어 효율적으로 메모리를 관리한다.</p>
<p>이 구조를 러스트 코드 형태로 확인해보자. 러스트에서는 중괄호를 이용해 임의의 장소에 블록을 선언할 수 있다.</p>
<p>(스포일러 주의! 예시에서 <code>String</code>타입을 사용했다는 것을 유념하자.)</p>
<pre><code class="language-rust  noplayground">{
    // 여기서 String 메모리를 확보
    let s = String::from(&quot;hello&quot;);
    // ...
    // ... 여기서 변수 s를 이용한 처리를 수행
    // ...
}
// 블록을 벗어나면 변수 s의 메모리를 파기</code></pre>
<p>이 예시는 기본적인 소유권 시스템의 동작을 나타낸다. 블록 안에서 확보된 메모리는 블록을 벗어나는 순간 자동으로 파기된다. 이처럼 러스트는 메모리의 유효 범위가 정해져 있다.</p>
<p>메모리를 확보한 후에 그 메모리를 누군가 책임지고 파기해야 하는 부분도 명확하게 정해져 있다.</p>
<p>예를 들어 다음과 같은 코드에서는 변수 <code>s1</code>에서 메모리를 확보한다. 그리고 도중에 변수 <code>s2</code>로 확보된 메모리가 이동된다.</p>
<pre><code class="language-rust  noplayground">{
    // 여기서 메모리를 확보
    let s1 = String::from(&quot;hello&quot;);
    
    // 다른 변수에 값을 넘긴다
    let s2 = s1;
}
// 블록을 벗어나면 변수 s2의 메모리를 파기</code></pre>
<p>이 경우 변수 <code>s1</code>에서 확보한 메모리는 <code>s2</code>로 이동된다. 변수 <code>s1</code>과 <code>s2</code>의 메모리를 모두 파기하려고 하면 메모리 이중 해제가 발생한다. 그래서 변수 <code>s1</code>에서 <code>s2</code>로 값을 이동한 것을 러스트
컴파일러가 검출해 변수 <code>s2</code>이 메모리만을 파기하도록 한다.</p>
<p>다음 그림은 프로그램의 동작과 그에 따른 메모리 상태를 나타낸다. 변수 <code>s1</code>에서 변수 <code>s2</code>로 메모리가 이동하면 변수 <code>s1</code>은 더 이상 이용할 수 없다. 그리고 블록을 벗어나면 변수 <code>s2</code>의 메모리가
파기된다. 메모리 이중 해제는 심각한 메모리 에러가 발생한다. 러스트 컴파일러는 변수 <code>s1</code>에서 변수 <code>s2</code>로 값이 이동할 때 <code>s1</code>을 이용할 수 없게 관리하므로 이중 해제는 발생하지 않는다.</p>
<p><img src="./images/ownership_01.png" alt="프로그램 동작과 메모리 상태" /></p>
<p>이 기본적인 구조를 러스트에서는 '소유권'이라고 한다. 그리고 메모리의 유효성을 검증하는 컴파일러의 이 기능을 Borrow checker(빌림 확인)라고 한다.</p>
<h3 id="소유권-시스템의-장점"><a class="header" href="#소유권-시스템의-장점">소유권 시스템의 장점</a></h3>
<p>러스트에는 이 소유권 시스템이 있기 때문에 수동으로 메모리 확보와 해제를 하는 C/C++ 언어에서 종종 발생하는 메모리 관련 오류(이중 해제, 미해제)는 발생하지 않는다. 해제된 메모리를 가리키는 포인터를 '댕글링
포인터(Dangling pointer)'라고 한다. 이 댕글링 포인터에 혹시 접근이 되면 보안 취약점으로 이어지는 경우가 있다. 러스트에서는 기본적으로 댕글링 포인터에 접근할 수 없다. 소유권 시스템으로 인해
메모리가 원인이 되는 문제는 원천적으로 방지되며 메모리 안전성이 확보된다. 이것은 큰 장점이다.</p>
<p>GC(가비지 컬렉터 - Garbage collector)가 있는 언어라면 이런 메모리 관련 문제로 고민하지 않아도 된다. 하지만 GC는 메모리 관리 때문에 실행 속도나 메모리 효율을 희생해야 한다는 단점이 있다.
러스트는 GC를 이용하지 않고 소유권 시스템을 통해 메모리 관리를 하므로 안전하며 효율적으로 고속 프로그램을 만들 수 있다.</p>
<h3 id="소유권-시스템의-단점"><a class="header" href="#소유권-시스템의-단점">소유권 시스템의 단점</a></h3>
<p>물론 소유권 시스템에 장점만 있지는 않다.</p>
<p>프로그래머가 소유권 시스템에 대해 제대로 이해해야 한다. 물론 새로운 프로그래밍 언어를 배울 때는 그 언어의 특징을 이해하는 것이 당연하지만 소유권 시스템은 다른 언어에서는 일반적인 개념은 아니므로 이해에 어려움이
따를 수 있다. 그리고 이는 러스트가 어렵다는 인상을 주는 데도 한몫한다.</p>
<blockquote>
<h4 id="소유권-시스템은-러스트-독자적인-것인가"><a class="header" href="#소유권-시스템은-러스트-독자적인-것인가">소유권 시스템은 러스트 독자적인 것인가?</a></h4>
<p>러스트의 소유권 시스템은 독자적으로 만든 것이 아니라 C++ 언어의 스마트 포인터(Smart pointer)가 그 기원이 된다. C++언어의 새로운 규격인 C++ 11(ISO/IEC 14882:2011)에는
표준으로 스마트 포인터를 이용할 수 있으며 소유권과 그 이동에 대한 기능이 포함돼 있다.</p>
</blockquote>
<h2 id="메모리-관리를-소유권으로-생각하는-것"><a class="header" href="#메모리-관리를-소유권으로-생각하는-것">메모리 관리를 '소유권'으로 생각하는 것</a></h2>
<p>'소유권'이라는 말의 의미는 무엇일까. 사전적인 정의를 보면 '물건을 전면적, 일반적으로 지배하는 권리. 물건이 가지는 사용 가치나 교환 가치의 전부를 지배할 수 있는 권리'라고 설명돼 있다. 그리고 '소유자'는 그
소유권을 가진 사람을 말한다.</p>
<p>예를 들어 어떤 집에 대한 소유권을 생각해보자. 집의 소유권을 가진 사람인 소유자는 그 집에서 살 수 있다. 가구 배치도 원하는 대로 할 수 있으며 집 안의 시설을 이용해 쾌적한 생활도 할 수 있다. 하지만 그 집을
누군가에게 팔면 그 집에 대한 아무런 권리도 없으므로 그 집에서 더 이상 살 수 없다.</p>
<p>러스트의 소유권 시스템도 이와 마찬가지다. 변수를 대입하거나 함수를 호출해 소유권을 가질 수 있지만 그 소유권이 한번 이동하면 원래의 변수는 다시 이용할 수 없다.</p>
<p>집은 소유하고 있는 중에 자기가 사는 것이 아니라 다른 누군가에게 세를 줄 수 있다. 이 경우 집의 소유권은 소유자에게 있지만 그 집에 살 수 있는 권리는 세입자에게 있다. 러스트에서도 이렇게 일시적으로 권리를
부여해줄 수 있다. 메모리 관리에 '소유권'이라는 말을 이용하는 것은 꽤 잘 어울린다.</p>
<h2 id="소유권의-3대-기본-원칙"><a class="header" href="#소유권의-3대-기본-원칙">소유권의 3대 기본 원칙</a></h2>
<p>러스트의 소유권 시스템에는 기본적인 세 가지 원칙이 있다.</p>
<ol>
<li><strong>값에는 '소유권'이 있으며 변수는 값의 '소유자'가 된다.</strong></li>
<li><strong>소유권은 이동할 수 있지만 '소유자'는 1개(1개의 변수)뿐이다.</strong></li>
<li><strong>'소유자'가 유효한 범위(Scope)를 벗어나면 값은 파기된다.</strong></li>
</ol>
<p>이 원칙을 조금 더 자세히 살펴보자.</p>
<p>원칙 1은 '소유권'과 '소유자'를 규정하는 것이다. 러스트에서 다루는 '값'에는 소유권이 있으며 그 소유권을 가지는 '소유자'가 있다는 것이다.</p>
<p>원칙 2는 값의 소유권은 한 변수에서 다른 변수로 '이동(move)'할 수 있다는 것이다. 소유권이 이동한 뒤에는 그 변수를 이용할 수 없다. 소유권의 이동은 변수에 값을 대입하거나 함수를 호출했을 때 발생한다.</p>
<p>예를 들어 물과 물컵을 가지고 생각해보자. 물컵이 '변수'이며 물 그 자체는 '소유권'이라고 가정한다.</p>
<p>물컵 a에 따른 물을 물컵 b에 옮겨 따랐다. 이때 물컵 a는 비어 있으므로 마실 수 없는 상태다. 마찬가지로 변수 a에 있는 소유권을 변수 b로 옮기면 변수 a는 값이 없는 상태이므로 사용할 수 없는 것이다.</p>
<p><img src="./images/ownership_02.png" alt="(원칙 1)과 (원칙 2) 값에는 소유권이 있으며 소유자 간에 이동한다." /></p>
<p>원칙 3은 소유권의 파기에 관한 규칙이다. 변수에는 이용 가능한 범위(Scope)가 있다. 변수가 유효한 범위를 벗어나면 자동적으로 변수는 파기된다. 그리고 변수를 파기할 때 변수가 값의 소유권을 가지고 있다면 값
역시 파기된다. 러스트에 소유권 시스템이 있는 것은 이렇게 명확한 메모리 파기 규칙을 위해서다.</p>
<p><img src="./images/ownership_03.png" alt="(원칙 3) 소유자가 유효 범위 밖으로 나갔을 때 값을 파기한다." /></p>
<h4 id="소유권-시스템-체험하기"><a class="header" href="#소유권-시스템-체험하기">소유권 시스템 체험하기</a></h4>
<p>소유권 시스템을 프로그램에서 직접 확인해보자. 다음은 소유권 시스템의 간단한 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let g1 = String::from(&quot;온화한 마음은 몸에 좋다.&quot;);  // (1)
    let g2 = g1;  // 소유권을 g2로 이동 (2)
    println!(&quot;{}&quot;, g2);  // (3)
}</code></pre></pre>
<p>이 소스 코드는 문제가 없다. (1)에서 <code>String::from</code> 메서드를 이용해 <code>String</code> 객체를 만들고 변수를 <code>g1</code>에 대입한다. 이때 <code>String</code> 객체의 소유자는 <code>g1</code>이다. <code>g1</code>
이 <code>String</code> 객체의 소유권을 가지고 있는 것이다.</p>
<p>그리고 (2)에서 변수 <code>g2</code>에 <code>g1</code>을 대입한다. 이를 통해 객체의 소유권은 <code>g1</code>에서 <code>g2</code>로 '이동(move)'한다.</p>
<p>(3)에서는 <code>g2</code>의 내용을 화면에 표시한다. <code>String</code> 객체의 값은 변수 <code>g1</code>에서 <code>g2</code>로 이동됐으므로 <code>g2</code>의 내용을 출력할 수 있다.</p>
<p>물컵의 예로 생각해보자. (1)에서는 물을 <code>g1</code>이라는 컵에 부었다. (2)에서는 <code>g2</code>라는 컵에 <code>g1</code>컵에 들어있던 물을 부었다. <code>g1</code>잔은 비어있으므로 마실 수 없다.</p>
<p>그렇다면 비어있는 <code>g1</code>을 이용하고자 하면 어떻게 될까. 위의 소스 코드를 변경해서 확인해보자.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let g1 = String::from(&quot;온화한 마음은 몸에 좋다.&quot;);  // (1)
    let g2 = g1;  // 소유권을 g2로 이동 (2)
    println!(&quot;{}&quot;, g1);  // 비어있는 g1을 이용할 수 있을까?
}</code></pre></pre>
<p>이 소스 코드를 컴파일하려 하면 다음과 같이 에러가 발생한다.</p>
<pre><code class="language-text">$ rustc owner_simple_err.rs
warning: unused variable: `g2`
 --&gt; owner_simple_err.rs:3:9
  |
3 |     let g2 = g1;  // 소유권을 g2로 이동
  |         ^^ help: if this is intentional, prefix it with an underscore: `_g2`
  |
  = note: `#[warn(unused_variables)]` on by default

error[E0382]: borrow of moved value: `g1`
 --&gt; owner_simple_err.rs:4:20
  |
2 |     let g1 = String::from(&quot;온화한 마음은 몸에 좋다.&quot;);
  |         -- move occurs because `g1` has type `String`, which does not implement the `Copy` trait       
3 |     let g2 = g1;  // 소유권을 g2로 이동
  |              -- value moved here
4 |     println!(&quot;{}&quot;, g1);  // 비어있는 g1을 이용할 수 있을까?
  |                    ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to previous error; 1 warning emitted

For more information about this error, try `rustc --explain E0382`.
</code></pre>
<p>'error[E0382]: borrow of moved value: <code>g1</code> (이동된 값 g1을 빌리려 했음)'이라는 에러가 발생한다. 그리고 <code>g1</code>에 'value borrowed here after move(이동
후에 여기서 값을 빌림)'라는 에러 메시지가 표시된다. 빌림은 소유권 시스템에서 이용하는 개념 중 하나로 소유자에게 값을 빌리거나 돌려줄 수 있다. 이에 대해서는 나중에 알아보자. 여기서는 물컵의 예에서 <code>g1</code>은
이미 빈 컵이므로 물을 마실 수 없다는 의미로 이해하자.</p>
<h3 id="소유자가-유효-범위에서-벗어나면-파기"><a class="header" href="#소유자가-유효-범위에서-벗어나면-파기">소유자가 유효 범위에서 벗어나면 파기</a></h3>
<p>3번째 원칙인 범위를 벗어나는 경우 값을 파기한다는 점에 대해서도 생각해보자. 러스트에서는 중괄호 <code>{ ... }</code>로 블록(범위)을 표현할 수 있다. 즉 중괄호 안에 선언한 변수에 대입한 값은 중괄호를 벗어나면
파기된다. 러스트는 범위를 벗어나면 <strong>범위 안에서 이용한 변수에 대해 자동으로 drop 함수를 호출</strong>한다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 블록
    {
        let s1 = String::from(&quot;재능은 한계가 있지만 노력엔 한계가 없다&quot;);
        println!(&quot;{}&quot;, s1);
    }
    // 블록을 벗어나면 s1은 파기된다.
}</code></pre></pre>
<p>여기서는 블록 안에서 <code>String</code>객체를 생성하고 변수 <code>s1</code>에 대입한다. 이때 변수 <code>s1</code>에 객체의 소유권이 있다. 이 블록을 벗어날 때, 즉 소유자 <code>s1</code>의 유효 범위에서 벗어날 때 <code>s1</code>이 소유권을
가지고 있던 <code>String</code>객체가 파기된다.</p>
<p>다음 프로그램도 확인해보자. 블록 1 안에서 또 다른 블록 2를 설정했다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 블록 1
    {
        let s1 = String::from(&quot;인생에 뜻을 세우는 데 있어 늦은 때라곤 없다.&quot;);
        let s3 = String::from(&quot;한걸음 한걸음씩&quot;);
        
        // 블록 2
        {
            let s2 = s1;
            println!(&quot;{}&quot;, s2);
        }
        // s2의 값은 여기서 파기된다.
        
        println!(&quot;{}&quot;, s3);
    }
    // s3의 값은 여기서 파기된다.
}</code></pre></pre>
<p>블록 1 안에서 <code>s1</code>과 <code>s3</code>에 <code>String</code> 객체를 만들어 대입했다. 블록 2 안에서 <code>s2</code>에 <code>s1</code>을 대입했다. 여기서 <code>s1</code>의 값 소유권이 <code>s2</code>로 이동한다. 그리고 이곳은 다른 블록의 안쪽이므로
이 블록을 벗어나면 변수 <code>s2</code>는 사용할 수 없다. 그와 동시에 <code>s2</code>가 소유권을 가지고 있는 값 '인생에 뜻을 세우는 데 있어 늦은 때라곤 없다.'라는 문자열도 파기된다. 마지막으로 블록 1이 종료될
때 <code>s3</code>의 값도 파기된다.</p>
<h2 id="소유권-시스템을-적용받지-않는-타입"><a class="header" href="#소유권-시스템을-적용받지-않는-타입">소유권 시스템을 적용받지 않는 타입</a></h2>
<p>러스트의 모든 값이 소유권 시스템의 대상이 되는 것은 아니다. 정수, 부동 소수점 등의 숫자 타입, Boolean 타입 등은 소유권 시스템이 동작하지 않는다. 이 타입은 대입(bind-속박)이나 함수 호출이 될 때
소유권이 이동(move)하는 것이 아니라 자동으로 복사(copy)된다. 따라서 소유권 이동은 일어나지 않는다. 이런 기본 타입은 컴파일할 때 데이터의 크기가 명확하게 결정되어 있어 해당 데이터가 스택 영역에
확보된다.</p>
<h3 id="힙-영역과-스택-영역"><a class="header" href="#힙-영역과-스택-영역">힙 영역과 스택 영역</a></h3>
<p>'힙(heap) 영역'과 '스택(stack) 영역'은 무엇일까. 메모리 관리는 OS의 일이다. OS는 응용 프로그램의 요청에 따라 메모리를 할당하거나 불필요해진 메모리를 회수한다. OS는 메모리를 할당할 때 크게 두
가지 방법으로 메모리를 관리한다. 이것이 힙과 스택이다.</p>
<p>'힙 영역'에 저장된 메모리는 임의의 순서로 메모리를 확보하거나 해제할 수 있다. 원할 때 필요한 만큼 메모리를 확보할 수 있다. 반면 '스택 영역'에 저장된 메모리는 순차적(마지막에 있는 메모리부터)으로만 메모리를
확보하고 해제할 수 있다.</p>
<p>따라서 메모리 크기가 이미 정해진 데이터는 스택 영역에 저장할 수 있지만 크기가 변하는 가변 데이터는 힙 영역에 저장해야 한다. 그래서 문자열(<code>String</code> 타입)이나 구조체 같이 크기가 변하는 데이터는 힙 영역에
저장된다.</p>
<p>반면 숫자 데이터 등의 기본 타입 데이터는 스택 영역에 저장되므로 데이터 복제가 빠르고 쉽다. 그래서 처음부터 소유권 관리를 하지 않고 값을 복사하는 것이다.</p>
<h3 id="기본-타입에서-소유권이-이동하지-않는-것을-확인"><a class="header" href="#기본-타입에서-소유권이-이동하지-않는-것을-확인">기본 타입에서 소유권이 이동하지 않는 것을 확인</a></h3>
<p>기본 타입 데이터에서 소유권이 정말 이동하지 않는지 프로그램을 만들어 확인해보자. 다음은 변수 <code>g2</code>에 <code>g1</code>의 값을 대입한 뒤 <code>g1</code>을 계속해서 이용하는 것을 보여주는 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let g1 = 30;
    let g2 = g1;  // 값이 자동으로 복사됨 (1)
    println!(&quot;{}&quot;, g1);  // ok
    println!(&quot;{}&quot;, g2);  // ok
}</code></pre></pre>
<p>컴파일 후 프로그램을 실행해보면 <code>g1</code>의 값과 <code>g2</code>의 값이 모두 출력되는 것을 확인할 수 있다.</p>
<p>컴파일 에러도 발생하지 않고, <code>g1</code>과 <code>g2</code>의 값을 모두 출력했다. 위 소스 코드를 소유권 에러가 발생했던 소스 코드와 비교해보자.</p>
<p>에러가 발생한 소스 코드에서는 <code>String</code>타입 데이터를 이용했고 이 소스 코드에서는 <code>i32</code>타입 데이터를 이용했다.</p>
<p>(1) 부분에서 <code>g1</code>의 값을 <code>g2</code>에 대입한다. 이때 기본 타입 데이터는 스택 영역에 저장되므로 직접 복사된다. 반면 기본 타입 외 데이터는 힙 영역에 보관되므로 소유권 시스템의 관리를 받게 된다. 따라서
복사가 아니라 이동으로 처리된다.</p>
<p>표를 통해 이 내용을 다시 한번 확인해보자.</p>
<div class="table-wrapper"><table><thead><tr><th>데이터 타입</th><th><code>let</code> 문으로 대입했을 때의 동작</th></tr></thead><tbody>
<tr><td>기본 타입(Primitive type - 원시 타입)</td><td>복사(copy)</td></tr>
<tr><td>기본형 외의 타입</td><td>이동(move)</td></tr>
</tbody></table>
</div>
<p>단, <strong>기본형 이외의 데이터 타입에서도 <code>Copy</code> 트레잇(<code>trait</code>)을 구현한 데이터 타입이라면 데이터를 복사 할 수 있다</strong>. 기본 타입 데이터는 모두 <code>Copy</code>트레잇이 구현되어 있다. 트레잇이란 다른
데이터형에 대해 공통 동작을 정의하는 것이다.</p>
<h3 id="참조-카운터로-값을-관리하는-rc와-arc"><a class="header" href="#참조-카운터로-값을-관리하는-rc와-arc">참조 카운터로 값을 관리하는 Rc<T>와 Arc<T></a></h3>
<p>기본 타입 값 이외에도 소유권 시스템에 적용되지 않는 값이 있다. 바로 <code>Rc&lt;T&gt;</code>와 <code>Arc&lt;T&gt;</code> 타입이다.</p>
<p>이 데이터 타입을 이용하면 참조 카운터를 사용해 메모리 관리를 할 수 있다. 표현 데이터에 따라서는 소유권 시스템보다 참조 카운터를 사용하는 게 메모리 관리에 유리할 수 있는데 그 경우 이 2가지 타입을 이용한다.</p>
<h4 id="복제할-때의-소유권"><a class="header" href="#복제할-때의-소유권">복제할 때의 소유권</a></h4>
<p>소유권이 이동하는 타입(문자열과 구조체)이라도 데이터를 복제(<code>clone</code>)해서 소유권 이동을 피할 수 있다. 다음은 <code>String</code>타입을 복제하는 예다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let g1 = String::from(&quot;온화한 마음은 몸에 좋다.&quot;);
    let g2 = g1.clone();  // 복제하면 소유권은 이동하지 않는다
    println!(&quot;{}&quot;, g1);  // ok
    println!(&quot;{}&quot;, g2);  // ok
}</code></pre></pre>
<p><code>g2</code>에 값을 대압하는 부분을 보면 <code>.clone()</code>이라는 메서드가 추가되어 있다. <code>String</code> 타입의 <code>clone</code> 메서드는 값을 복제하는 메서드다. 단순히 대입을 하면 소유권이 이동하지만 복제를 하면
소유권은 이동하지 않는다. 따라서 <code>g1</code>과 <code>g2</code>를 모두 이용할 수 있다.</p>
<div style="break-before: page; page-break-before: always;"></div><p>#패스트캠퍼스, #국비지원교육, #메가바이트스쿨, #MegabyteSchool, #개발자취업부트캠프, #내일배움카드</p>
<p><em>last edited 2023.01.26</em></p>
<h1 id="빌림과-참조에-대해-쉬운-설명으로-알아보자"><a class="header" href="#빌림과-참조에-대해-쉬운-설명으로-알아보자">빌림과 참조에 대해 쉬운 설명으로 알아보자</a></h1>
<blockquote>
<p>▶ 만들면서 배우는 러스트 프로그래밍 -쿠지라 히코우즈쿠에- ◀ 을 참조하여 정리하였다.</p>
</blockquote>
<p>소유권은 함수를 호출해도 이동한다. 하지만 함수를 호출할 때마다 소유권이 이동하면 프로그래밍이 어려워진다. 그래서 일시적으로 소유권을 빌리는 '빌림'에 대해 알아보자. 빌림 외에도 함수와 소유권의 관계, 참조에
대해서도 알아본다.</p>
<h2 id="빌림이란"><a class="header" href="#빌림이란">'빌림'이란</a></h2>
<p>'빌림'은 빌려쓴다는 뜻이다. 실생활에서도 자기 것이 아닌 물건을 원 주인의 양해를 받고 가져와 쓰는 것을 빌린다고 한다.</p>
<p>러스트에서 말하는 빌림(borrow/borrowing)도 의미는 같지만 여기서는 물건이 아니라 값의 소유권이다. 그리고 빌리는 것이므로 소유권을 완전히 받는 것이 아니라 일시적으로 가져오고 사용이 끝나면 반납한다.</p>
<h2 id="함수-호출로-이동하는-소유권"><a class="header" href="#함수-호출로-이동하는-소유권">함수 호출로 이동하는 소유권</a></h2>
<p>소유권은 값 대입 외 함수 호출로도 이동한다. 함수를 호출할 때 인수로 값을 지정하면 그 값의 소유권은 호출한 함수의 인수로 이동한다.</p>
<p>함수 호출에 따른 소유권 이동에 대해 자세히 살펴보자.</p>
<pre><code class="language-rust  noplayground">fn main() {
    let g1 = String::from(&quot;실수할 줄 아는 사람이 아름답다.&quot;);
    show_message(g1);  // 소유권이 이동한다
    println!(&quot;{}&quot;, g1);  // g1은 사용할 수 없다.
}

fn show_message(message: String) {
    println!(&quot;{}&quot;, message);
}</code></pre>
<p>이 프로그램을 컴파일하면 다음과 같이 에러가 발생한다.</p>
<pre><code class="language-text">$ rustc owner_func_err.rs
error[E0382]: borrow of moved value: `g1`
 --&gt; owner_func_err.rs:4:20
  |
2 |     let g1 = String::from(&quot;실수할 줄 아는 사람이 아름답다&quot;);
  |         -- move occurs because `g1` has type `String`, which does not implement the `Copy` trait       
3 |     show_message(g1);  // 소유권이 이동한다
  |                  -- value moved here
4 |     println!(&quot;{}&quot;, g1);  // g1은 사용할 수 없다
  |                    ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
</code></pre>
<p>에러 메시지를 확인해보자. 직접적인 에러는 'error[E0382]: borrow of moved value: <code>g1</code>(이동된 값 g1을 빌림)'이다.</p>
<p>여기서 주목할 점은 어디에서 <code>g1</code>의 값이 이동했는지다. 프로그램의 3번째 줄에서 호출한 함수 <code>show_message</code>의 인수 <code>g1</code>부분에 'value moved here(여기에서 값이 이동됨)'이라는 힌트가
표시된다.</p>
<p>즉 함수 호출로 소유권 이동이 발생했으므로 4번째 줄의 <code>println!</code>에서 <code>g1</code>의 값을 사용할 수 없게 된 것이다.</p>
<h3 id="소유권-돌려주기"><a class="header" href="#소유권-돌려주기">소유권 돌려주기</a></h3>
<p>앞의 예제에서는 변수 <code>g1</code>의 소유권이 이동했으므로 에러가 발생했다. 이번에는 <code>g1</code>을 이용하면 함수를 호출한 곳에 소유권을 돌려주도록 해보자.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let mut g1 = String::from(&quot;실수할 줄 아는 사람이 아름답다.&quot;);
    g1 = show_message(g1);  // (1)
    println!(&quot;{}&quot;, g1);  // ok (2)
}

// String을 받아 String을 반환하는 함수
fn show_message(message: String) -&gt; String {
    println!(&quot;{}&quot;, message);
    return message;
}</code></pre></pre>
<p>컴파일 후 실행해보면 '실수할 줄 아는 사람이 아름답다.'라는 문장이 2번 출력된다.</p>
<p>소스 코드를 살펴보자. (1)에서는 변수 <code>g1</code>의 값을 인수로 지정해 함수를 호출한다. 이를 통해 <code>g1</code>값의 소유권은 함수로 넘어간다. 하지만 함수의 반환 값을 통해 소유권을 다시 돌려받는다. 그래서 (2)
에서도 <code>g1</code>을 이용할 수 있다.</p>
<p>물컵의 예로 생각하면 <code>g1</code>컴에 따라둔 물을 <code>show_message</code>함수의 인수 <code>message</code>라는 컵으로 옮긴 후 다시 <code>g1</code>컵으로 옮긴 상태다.</p>
<p>여기서 변수 <code>g1</code>을 선언할 때 <code>mut</code>을 붙여 가변 변수로 선언을 했다. 동일한 값인데 <code>mut</code>을 선언한 이유는 내부적으로 대입 동작이 발생하기 때문이다. 대입은 초기화와는 다른 동작이므로 값이 변하는 것으로
간주되기 때문이다.</p>
<p>(3)의 함수 <code>show_message</code>가 이전 예제와 다른 점은 인수 <code>message</code>를 그대로 반환 값으로 한 것이다. 이를 통해 함수를 호출했을 때 값 소유권을 함수의 변수 <code>message</code>로 이동한 뒤 실행이
종료되면 다시 함수를 호출한 곳으로 돌려줄 수 있다.</p>
<h3 id="참조와-빌림---함수-호출을-했을-때-소유권을-이동하지-않는-방법"><a class="header" href="#참조와-빌림---함수-호출을-했을-때-소유권을-이동하지-않는-방법">참조와 빌림 - 함수 호출을 했을 때 소유권을 이동하지 않는 방법</a></h3>
<p>함수 호출만으로 값의 소유권이 이동하는 것은 불편할 때도 있다. 그래서 러스트에는 소유권을 일시적으로 빌려주는 '빌림(borrow)'이라는 시스템을 마련해두고 있다.</p>
<p>값을 빌리기 위해서는 참조자를 나타내는 <code>&amp;</code>을 붙인다. 바꿔 말하면 <strong>함수의 인수를 '참조자'로 만드는 것을 '빌림'이라고 한다</strong>.</p>
<p>앞에서 다룬 예제를 빌림을 이용하는 형태로 변경해보자.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let g1 = String::from(&quot;실수할 줄 아는 사람이 아름답다.&quot;);
    show_message(&amp;g1);  // 참조 값을 전달 (1)
    println!(&quot;{}&quot;, g1);  // 소유권은 이동하지 않음 (2)
}

fn show_message(message: &amp;String) {  // (3)
    println!(&quot;{}&quot;, message);
}</code></pre></pre>
<p>컴파일 후 실행해보면 앞서와 마찬가지로 <code>show_message</code>에서 한 번, <code>println!</code>에서 한 번씩 메시지가 출력되어 총 2개의 메시지가 출력된다.</p>
<p>가장 앞 부분에서 설명한 에러가 발생하는 소스 코드와 비교해보면 차이점은 단 2글자뿐이다. (1)에서 함수를 호출할 때 참조자라는 것을 명시하기 위해 <code>&amp;</code>를 붙인 것, 그리고 (3)에서 함수의 인자로 참조자를
전달한다는 것을 명시하기 위해 역시 <code>&amp;</code>을 붙인 것이 전부다. 이를 통해 (2)에서 변수 <code>g1</code>의 값을 이용할 수 있다.</p>
<p>이처럼 참조자를 전달하도록 변경하면 소유권 문제를 해결할 수 있다. <strong>값을 참조해서 사용한다는 것은 값의 소유권을 일시적으로 빌리는 '빌림'이기 때문이다</strong>.</p>
<blockquote>
<h4 id="string은-str과-다른가"><a class="header" href="#string은-str과-다른가">&amp;String은 &amp;str과 다른가</a></h4>
<p>앞의 프로그램에서는 <code>String</code> 타입의 참조 타입인 <code>&amp;String</code>을 썼다. 하지만 문자열 참조 타입으로 <code>&amp;str</code>을 이용할 수도 있다. 러스트의 많은 함수는 문자열 참조 타입으로 <code>&amp;str</code>을
이용한다. <code>&amp;String</code>과 <code>&amp;str</code>은 대부분의 경우 동일하게 사용할 수 있다. 하지만 엄밀히 말하면 <code>&amp;str</code>은 슬라이스다. 슬라이스는 배열과 같은 요소의 일부를 참조하기 위한 타입이다. 자세한 내용은
문자열에 대해 알아볼때 다뤄보자.</p>
</blockquote>
<h2 id="참조자를-반환하는-함수"><a class="header" href="#참조자를-반환하는-함수">참조자를 반환하는 함수</a></h2>
<p>함수에서 참조자를 반환해야 하는 경우도 있다. 예를 들어 함수 안에서 어떠한 데이터를 만들고, 값이 아니라 그 참조자를 반환해야 하는 경우다. 그런데 러스트에서는 값에 수명(Lifetime)이 있다.</p>
<p>다음 소스 코드는 함수 <code>gen_message</code>로 메시지를 만든 뒤 그 참조자를 반환하려는 의도로 만들어진 것이다. 하지만 에러가 발생한다. 어떤 부분이 잘못되었는지 살펴보자.</p>
<pre><code class="language-rust  noplayground">// 메시지를 생성한 뒤 그 참조자를 반환하는 함수
fn gen_message() -&gt; &amp;str {
    let msg = String::from(&quot;실수할 줄 아는 사람이 아름답다.&quot;);
    return &amp;msg;
}

fn main() {
    let m = gen_message();
    println!(&quot;{}&quot;, m);
}</code></pre>
<pre><code class="language-text">$ rustc owner_lifetime_err.rs 
error[E0106]: missing lifetime specifier
 --&gt; owner_lifetime_err.rs:2:21
  |
2 | fn gen_message() -&gt; &amp;str {
  |                     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
2 | fn gen_message() -&gt; &amp;'static str {
  |                      +++++++

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
</code></pre>
<p>에러 메시지를 확인해보자. 'error[E0106]: missing lifetime specifier(수명 지시자가 없음)'이라고 표시된다. 도움말(help)을 보면 'this function's return
type contains a borrowed value, but there is no value for it to be borrowed from(이 함수가 반환하는 값은 빌린 값을 포함하고 있으나 빌림 값이 존재하지
않음)'이라고 표시된다.</p>
<p>즉, 수명을 지정하지 않았기 때문에 에러가 발생한 것이다.</p>
<p>앞에서 '소유자'가 유효한 범위(Scope)를 벗어나면 값은 파기된다'는 소유권 시스템의 기본 원칙을 바탕으로 생각해보자. 함수 <code>gen_message</code>는 하나의 범위다. 변수 <code>msg</code>는 <strong>이 범위 안에서만
유효하며 범위를 벗어나는 순간 <code>msg</code>값은 파기되는 것이다</strong>. 따라서 <code>msg</code>의 값에 대한 참조를 반환하더라도 <code>msg</code>값은 파기되므로 값이 사라지기 때문에 에러가 발생한다.</p>
<p>그렇다면 이 소스 코드를 어떻게 고쳐야 할까? <strong>참조가 안 된다면 실제값을 이용하면 된다</strong>. 즉 참조가 아닌 <code>String</code>객체의 실제값을 반환하도록 수정한다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">// 메시지 생성 함수
fn gen_message() -&gt; String {
    let msg = String::from(&quot;실수할 줄 아는 사람이 아름답다.&quot;);
    return msg;  // 소유권이 함수의 반환 값으로 이동 (1)
}

fn main() {
    let m = gen_message();  // 소유권은 m으로 이동 (2)
    println!(&quot;{}&quot;, m);  // ok
}</code></pre></pre>
<p>(1)부분에서 변수 <code>msg</code>값의 소유권은 함수의 반환 값으로 이동한다. 즉, (2)부분의 변수 <code>m</code>이 <code>msg</code>값의 소유권을 가지게 된다. 따라서 <code>println!</code> 매크로로 <code>m</code>의 값을 출력할 수 있다.</p>
<h2 id="가변-참조자를-인수로-사용하기"><a class="header" href="#가변-참조자를-인수로-사용하기">가변 참조자를 인수로 사용하기</a></h2>
<p>함수 호출에 참조자를 사용할 때 함수 안에서 인수의 값을 변경해야 하는 경우도 있다. 이때는 참조자가 가변이라는 것을 명시하면 함수 안에서 인수의 값을 변경할 수 있다.</p>
<p>다음은 인수에 지정한 <code>String</code> 타입 값을 함수 안에서 변경하는 프로그램이다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">// 인수의 문자열을 변경하는 함수 (1)
fn add_quote(msg: &amp;mut String) {
    msg.insert(0, '&quot;');
    msg.push('&quot;');
}

fn main() {
    let mut msg = String::from(&quot;건강한 신체에 건강한 정신이 깃든다.&quot;);
    println!(&quot;{}&quot;, msg);  // (2)
    add_quote(&amp;mut msg);  // (3)
    println!(&quot;{}&quot;, msg);  // (4)
}</code></pre></pre>
<p>컴파일 후 실행해보면 문자열의 앞뒤에 큰따옴표가 추가된 것을 확인할 수 있다.</p>
<p>함수의 인수로 지정한 값의 참조자를 변경하려면 (1)의 함수 정의에서 인수를 <code>&amp;mut</code> 타입 형태로 지정한다. 이렇게 하면 그 타입이 가변 참조자가 된다. 그리고 (3)에서와 같이 함수를 호출할 때 <code>&amp;mut</code>을
지정해 함수를 호출한다.</p>
<p><code>main</code>함수를 보면 <code>String</code>타입 값을 만들고 가변 변수 <code>msg</code>에 대입한다. 그리고 (2)에서 내용을 출력한다. (3)에서는 <code>add_quote</code>함수를 호출한다. 호출할 때 인수에 <code>&amp;mut</code>을 추가해
가변 참조자라는 것을 명시한다. <code>add_quote</code>함수는 <code>msg</code>의 앞과 뒤에 큰따옴표를 추가한다. 그리고 (4)에서 큰따옴표가 추가된 문자열을 출력한다.</p>
<p>여기서 주의할 것은 <code>add_quote</code>함수를 호출할 때 값 그 자체가 아니라 <code>mut</code>에 <code>&amp;</code>를 붙여 가변 참조자를 지정한다는 점이다. 참조자이므로 값을 빌리기만 하므로 (4)에서 <code>msg</code>를 이용할 수 있다.</p>
<h3 id="함수를-호출해서-인수를-변경하는-방법"><a class="header" href="#함수를-호출해서-인수를-변경하는-방법">함수를 호출해서 인수를 변경하는 방법</a></h3>
<p>함수의 인수로 지정한 변수를 변경하는 방법을 다시 한번 확인하자. 문법은 다음과 같다.</p>
<pre><code class="language-rust  noplayground">// 함수 정의
fn 함수이름(변수명: &amp;mut 타입) {
    // 실제값을 얻음
    let value = *변수명;
    
    // 변수를 갱신
    *변수명 = 새로운 값;
}

// 함수 호출
함수(&amp;mut 변수);</code></pre>
<p>함수를 정의할 때 변수에 대한 참조자를 전달할 수 있게 <code>변수명: &amp;mut 타입</code>을 지정한다. 그리고 함수를 호출할 때는 <code>함수(&amp;mut 변수)</code>와 같이 변수가 가변이며 참조자라는 것을 명시한다.</p>
<p>함수의 실제 내용에는 변수의 참조자로부터 실제값을 얻기 위해 <code>*변수명</code>과 같이 기술한다. 이것을 '역참조(dereference)'라고 한다. 값을 변경하는 경우에도 역참조를 지정해 <code>*변수명 = 새로운 값;</code>과
같이 기술한다.</p>
<h3 id="인수를-변경하는-예"><a class="header" href="#인수를-변경하는-예">인수를 변경하는 예</a></h3>
<p>다음은 가변 변수를 선언한 뒤 함수를 이용해 원래의 변수값을 변경하는 간단한 예이다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">// 인수의 값에 2를 곱해 반환하는 함수 (1)
fn x2(arg: &amp;mut i32) {
    *arg = *arg * 2;
}

fn main() {
    let mut v = 16;
    x2(&amp;mut v);  // 인수에 2가 곱해진다 (2)
    println!(&quot;{}&quot;, v);
}</code></pre></pre>
<p>컴파일 후 실행해보면 원래 16이었던 <code>v</code>의 값이 2배가 되어 32가 출력된다.</p>
<p>프로그램을 확인해보자. (1)은 인수로 전달된 값에 2를 곱하는 함수다. 여기서 중요한 점은 가변 참조자를 이용할 수 있도록 인수 타입 앞에 <code>&amp;mut</code>을 붙이는 것이다.</p>
<p>(2)에서는 함수를 호출한다. 이 함수에 전달하는 인수는 가변 참조자여야 하기 때문에 <code>&amp;mut</code>을 붙인다.</p>
<h3 id="참조-호출과-값-호출의-차이"><a class="header" href="#참조-호출과-값-호출의-차이">참조 호출과 값 호출의 차이</a></h3>
<p>함수를 호출할 때 인수를 어떻게 전달하느냐에 따라 값 호출(Call by Value)와 참조 호출(Call by Reference)로 나뉜다. 러스트뿐 아니라 다른 일반적인 프로그래밍 언어에서도 이 두 가지 방법이
사용된다.</p>
<p>값 호출은 값 그 자체를 인수로 전달하는 것이며 참조 호출은 변수의 참조자를 사용하는 것이다.</p>
<p>함수를 호출할 때 '값 전달'이 이루어지면 함수의 인수로 지정된 '값'이 그대로 전달되는 것이 아니라 값이 복사되어 함수로 전달된다. 그러므로 함수 안에서 그 값이 어떻게 가공이 되더라도 변수를 호출한 곳에서는
아무런 영향을 받지 않는다. 즉 안전하다. 물론 함수의 인수로 변수를 지정했을 때도 전달되는 것은 변수가 아니라 변수 '값'의 사본이기 때문에 호출한 곳의 변수는 영향을 받지 않는다.</p>
<p>반면 '참조 호출'은 참조자(변수가 가리키는 주소)가 전달된다. 이 경우 함수 안에서 인수의 내용을 변경하면 함수를 호출한 곳의 값도 바뀐다.</p>
<p>러스트에서 참조 전달을 하는 경우 함수의 인수에 참조를 나타내는 <code>&amp;</code>를 지정한다. 러스트에서 값 전달을 하는 경우 소유권 시스템의 규칙이 적용된다. 즉 기본 타입(또는 <code>Copy</code>트레잇이 구현된 타입)이라면 값이
복사되지만 그 외의 타입에서는 소유권이 이동한다.</p>
<blockquote>
<h4 id="println-매크로-사용-방법-정리"><a class="header" href="#println-매크로-사용-방법-정리">println! 매크로 사용 방법 정리</a></h4>
<p><code>println!</code>은 표준 출력으로 임의의 서식을 가진 문자열을 출력하는 매크로다. 러스트 프로그래밍을 하는 데 있어 가장 자주 사용하는 기능 중 하나다. 여기서는 <code>println!</code>매크로 사용 방법을
정리해본다.</p>
<p><strong>소유권 문제가 발생하지 않는다.</strong></p>
<p><code>println!</code>매크로는 소유권과 관련된 문제가 발생하지 않게 구현되어 있다. 다음은 <code>println!</code>을 모방해 <code>echo</code>함수를 만들어 사용하는 예이다. 하지만 이 함수는 소유권이 이동하기 때문에 에러가
발생한다.</p>
<pre><code class="language-rust  noplayground">fn main() {
    let s = &quot;Fast and Robust&quot;.to_string();
    echo(s);  // &lt;- 소유권이 이동한다.
    println!(&quot;{}&quot;, s);
}

// println!을 모방한 함수
fn echo(s: String) {
    println!(&quot;{}&quot;, s);
}</code></pre>
<p>컴파일을 해보면 소유권과 관련된 에러가 발생한다. 하지만 <code>println!</code>매크로를 이용하면 문제가 없으며, 다음과 같이 몇 번이나 같은 값을 이용할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let s = &quot;Fast and Robust&quot;.to_string();
    println!(&quot;{}&quot;, s);  // 소유권이 이동하지 않는다.
    println!(&quot;{}&quot;, s);
}</code></pre></pre>
<p><strong>값을 임의의 장소에 넣을 수 있다.</strong></p>
<p>변수나 값을 문자열 안의 임의의 장소에 넣을 수 있다. 그리고 값을 순서대로 채워넣는 것이 아니라 <code>...{2}...{1}...{0}...</code>과 같이 순서를 임의로 지정할 수도 있다.</p>
<p>예를 들어 연도 표시 방법은 나라에 따라 상이하다. 미국에서는 '월/일/년' 순으로 쓰지만 영국에서는 '일/월/년' 순으로 쓴다. 인수 순서는 변경하지 않고 서식만 변경해서 이런 문제에 대응할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let year = 2023;
    let month = 12;
    let day = 1;
    println!(&quot;KR:{0}/{1}/{2}&quot;, year, month, day);  // 한국
    println!(&quot;US:{1}/{2}/{0}&quot;, year, month, day);  // 미국
    println!(&quot;UK:{2}/{1}/{0}&quot;, year, month, day);  // 영국
}</code></pre></pre>
<p>그리고 다음과 같이 인수에 이름을 붙여서 대입하는 것도 가능하다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    let year = 2023;
    let month = 12;
    let day = 1;
    println!(&quot;{yy}년 {mm}월 {dd}일&quot;, dd = day, mm = month, yy = year);
}</code></pre></pre>
<p><strong>서식(format)을 지정할 수 있다.</strong></p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>서식</th><th>설명</th><th>사용 예</th><th>입력</th><th>결과</th></tr></thead><tbody>
<tr><td><code>{:&lt;n}</code></td><td>n자리 왼쪽 정렬</td><td><code>_{:&lt;5}_</code></td><td>30</td><td>_30   _</td></tr>
<tr><td><code>{:&gt;n}</code></td><td>n자리 오른쪽 정렬</td><td><code>_{:&gt;5}_</code></td><td>30</td><td>_   30_</td></tr>
<tr><td><code>{:^n}</code></td><td>n자리 가운데 정렬</td><td><code>_{:5}_</code></td><td>3</td><td>_  3  _</td></tr>
<tr><td><code>{:0&lt;n}</code></td><td>n자리 왼쪽 정렬 후 0으로 채움</td><td><code>_{:0&lt;5}_</code></td><td>12</td><td><em>12000</em></td></tr>
<tr><td><code>{:&gt;0n}</code></td><td>n자리 오른쪽 정렬 후 0으로 채움</td><td><code>_{:&gt;05}_</code></td><td>12</td><td><em>00012</em></td></tr>
<tr><td><code>{:b}</code></td><td>2진수</td><td><code>{:b}</code></td><td>4</td><td>100</td></tr>
<tr><td><code>{:0nb}</code></td><td>2진수에서 n만큼 0으로 채움</td><td><code>{:08b}</code></td><td>4</td><td>00000100</td></tr>
<tr><td><code>{:o}</code></td><td>8진법</td><td><code>{:o}</code></td><td>438</td><td>666</td></tr>
<tr><td><code>{:x}</code></td><td>16진수</td><td><code>{:x}</code></td><td>255</td><td>ff</td></tr>
<tr><td><code>{:0nx}</code></td><td>16진수에서 n만큼 0으로 채움</td><td><code>{:04x}</code></td><td>15</td><td>000f</td></tr>
<tr><td><code>{:.n}</code></td><td>소수점 이하 n자리 표시</td><td><code>{:.2}</code></td><td>3.1415</td><td>3.14</td></tr>
<tr><td><code>{:e}</code></td><td>지수 표시</td><td><code>{:e}</code></td><td>12.34</td><td>1.234e1</td></tr>
<tr><td><code>{:?}</code></td><td>디버그 출력</td><td><code>{:?}</code></td><td>[1,2,3]</td><td>[1, 2, 3]</td></tr>
<tr><td><code>{:#?}</code></td><td>디버그 출력(형태 정렬)</td><td><code>{:#?}</code></td><td>[1,2]</td><td>[(줄바꿈) 1, (줄바꿈) 2, (줄바꿈)]</td></tr>
<tr><td><code>{{</code></td><td>{를 출력</td><td><code>{{</code></td><td>없음</td><td>{</td></tr>
<tr><td><code>}}</code></td><td>}를 출력</td><td><code>}}</code></td><td>없음</td><td>}</td></tr>
<tr><td><code>{:p}</code></td><td>포인터</td><td><code>{:p}</code></td><td>abc</td><td>(예)0x1022c2970</td></tr>
<tr><td><code>\&quot;</code></td><td>&quot;를 출력</td><td><code>\&quot;</code></td><td>없음</td><td>&quot;</td></tr>
<tr><td><code>\\</code></td><td>\를 출력</td><td><code>\\</code></td><td>없음</td><td>\</td></tr>
</tbody></table>
</div>
<blockquote>
<p>서식을 이용해 보자.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 오른쪽 정렬 및 16진수 출력
    println!(&quot;|{:&gt;8}| #{:06x}&quot;, &quot;red&quot;, 0xFF0000);
    println!(&quot;|{:&gt;8}| #{:06x}&quot;, &quot;green&quot;, 0x00FF00);
    println!(&quot;|{:&gt;8}| #{:06x}&quot;, &quot;blue&quot;, 0x0000FF);

    // 디버그 출력
    println!(&quot;|{:&gt;8}| RGB{:?}&quot;, &quot;yellow&quot;, (255, 255, 0));
}</code></pre></pre>
<p>이렇게 <code>println!</code>은 다양한 표현을 할 수 있으므로 활용도가 높다. <code>println!</code>은 표준 출력 용도이지만 문자열을 출력하지 않고 <code>String</code>타입으로 만들어 주는 <code>format!</code>매크로도
있다. <code>format!</code>매크로 역시 <code>println!</code>매크로와 사용 방법은 동일하다. <code>format!</code>매크로 역시 활용도가 높으므로 사용법을 잘 익혀두자.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="러스트의-문자열"><a class="header" href="#러스트의-문자열">러스트의 문자열</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
